import{PrivyClientError as a}from"../errors.mjs";import{getWalletApiSearchPath as e,getWalletApiGetPath as t,getPolicyPath as i,updatePolicyPath as r,deletePolicyPath as n,createPolicyRulePath as s,updatePolicyRulePath as o,deletePolicyRulePath as d,getPolicyRulePath as c,getTransactionGetPath as p,getWalletApiCreatePath as h,getWalletApiRpcPath as y,createPolicyPath as m}from"../paths.mjs";import{g as u}from"../utils-DRjOr8oi.mjs";import{convertPolicyResponseToPolicy as l,convertPolicyCreateRequestToPolicy as g,convertPolicyCreateRuleToPolicyRule as _}from"./mappers.mjs";import{EthereumRpcApi as w}from"./rpc/ethereum.mjs";import{SolanaRpcApi as f}from"./rpc/solana.mjs";import{normalizeP256PrivateKeyToScalar as v,createP256KeyPair as P,decryptHPKEMessage as I,extractIdempotencyKeyHeader as z,createAuthorizationSignatureHeader as b,getWalletIdFromAddress as T,signAuthorizationSignatureRequest as K,formatAuthorizationSignatureRequest as x}from"./utils.mjs";import"node-fetch-native";import"ts-case-convert";import"@hpke/chacha20poly1305";import"@hpke/core";import"@noble/curves/p256";import"@noble/hashes/sha256";import"canonicalize";import"../constants.mjs";function S(a,e){if(!Object.prototype.hasOwnProperty.call(a,e))throw TypeError("attempted to use private field on non-instance");return a}var k=0,A="__private_"+k+++"__getRequestHeaders";class E{async getWallets(a={}){let{cursor:t,limit:i,chainType:r}=a,{data:n}=await this.api.get(e()+u({cursor:t,limit:i,chain_type:r}));return{nextCursor:n.next_cursor??void 0,data:n.data.map((a=>({id:a.id,address:a.address,chainType:a.chain_type,policyIds:a.policy_ids,createdAt:new Date(a.created_at)})))}}async getWallet({id:a}){let{data:e}=await this.api.get(t(a));return{id:e.id,chainType:e.chain_type,address:e.address,policyIds:e.policy_ids,createdAt:new Date(e.created_at)}}updateAuthorizationKey(a){this.authorizationPrivateKey=v(a),this.ethereum=new w({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new f({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey})}async generateUserSigner({userJwt:a}){let{publicKey:e,privateKey:t}=await P(),{data:i}=await this.api.post("/api/v1/user_signers/authenticate",{encryption_type:"HPKE",recipient_public_key:e.toString("base64"),user_jwt:a});return{authorizationKey:await I(t.toString("base64"),i.encrypted_authorization_key.encapsulated_key,i.encrypted_authorization_key.ciphertext),expiresAt:new Date(i.expires_at),wallets:i.wallets.map((a=>({id:a.id,address:a.address,chainType:a.chain_type,policyIds:a.policy_ids,createdAt:new Date(a.created_at)})))}}async getPolicy({id:a}){let{data:e}=await this.api.get(i(a));return l(e)}async createPolicy(a){let e=m(),t=g(a),{data:i}=await this.api.post(e,t,{headers:S(this,A)[A]({path:e,body:t,method:"POST"})});return l(i)}async updatePolicy(a){let e=r(a.id),t={name:a.name,rules:a.rules?_(a.rules):void 0},{data:i}=await this.api.patch(e,t,{headers:S(this,A)[A]({path:e,body:t,method:"PATCH"})});return l(i)}async deletePolicy(a){let e=n(a.id),t={};await this.api.delete(e,t,{headers:S(this,A)[A]({path:e,body:t,method:"DELETE"})})}async addRuleToPolicy(a){let e=s(a.policyId),t={name:a.name,action:a.action,method:a.method,conditions:a.conditions},{data:i}=await this.api.post(e,t,{headers:S(this,A)[A]({path:e,body:t,method:"POST"})});return i}async updateRuleInPolicy(a){let e=o(a.policyId,a.ruleId),t={name:a.name,action:a.action,method:a.method,conditions:a.conditions},{data:i}=await this.api.patch(e,t,{headers:S(this,A)[A]({path:e,body:t,method:"PATCH"})});return i}async deleteRuleFromPolicy(a){let e=d(a.policyId,a.ruleId),t={};await this.api.delete(e,t,{headers:S(this,A)[A]({path:e,body:t,method:"DELETE"})})}async getRuleInPolicy(a){let e=c(a.policyId),{data:t}=await this.api.get(e);return t}async getTransaction({id:a}){let{data:e}=await this.api.get(p(a));return{id:e.id,walletId:e.wallet_id,caip2:e.caip2,transactionHash:e.transaction_hash,status:e.status}}async create(a){return await this.createWallet(a)}async createWallet(a){let{chainType:e,authorizationKeyIds:t,authorizationThreshold:i}=a,r={};"ownerId"in a&&a.ownerId?r={owner_id:a.ownerId}:"owner"in a&&a.owner&&(r={owner:{public_key:a.owner.publicKey}});let n={};"authorizationKeyIds"in a||"authorizationThreshold"in a?n={authorization_key_ids:t,authorization_threshold:i}:"additionalSigners"in a&&a.additionalSigners&&(n={additional_signers:a.additionalSigners.map((a=>({signer_id:a.signerId})))});let s={chain_type:e,...r,...n},o=z(a),d=b({method:"POST",url:`${this.api.baseURL}${h()}`,body:s,appId:this.appId,idempotencyKeyHeader:o,authorizationPrivateKey:this.authorizationPrivateKey}),{data:c}=await this.api.post(h(),s,{headers:{...d,...o}});return{id:c.id,address:c.address,chainType:c.chain_type,policyIds:c.policy_ids,createdAt:new Date(c.created_at)}}async rpc(e){let t;if("walletId"in e)t=y(e.walletId);else{if(!("address"in e))throw new a("Invalid RPC payload. Must include `walletId`.");{console.warn("Warning: using deprecated input 'address' this will be removed in a a future version. Use 'walletId' instead.");let i=await T(this.api,e.address);if(!i)throw new a(`No wallet account found for address ${e.address}`);t=y(i)}}let i=function(a){let{method:e,params:t}=a,i="address"in a?{address:a.address,chain_type:a.chainType}:{wallet_id:a.walletId};switch(e){case"signTransaction":return{...i,method:e,params:{transaction:Buffer.from(t.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"signMessage":{let a=Buffer.from(t.message).toString("base64");return{...i,method:e,params:{message:a,encoding:"base64"}}}case"signAndSendTransaction":return{...i,method:e,caip2:a.caip2,params:{transaction:Buffer.from(t.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"eth_signTransaction":return{...i,method:e,params:{transaction:{from:t.transaction.from,to:t.transaction.to,nonce:t.transaction.nonce,chain_id:t.transaction.chainId,data:t.transaction.data,value:t.transaction.value,type:t.transaction.type,gas_limit:t.transaction.gasLimit,gas_price:t.transaction.gasPrice,max_fee_per_gas:t.transaction.maxFeePerGas,max_priority_fee_per_gas:t.transaction.maxPriorityFeePerGas}}};case"personal_sign":let r;return r=t.message instanceof Uint8Array?{message:Buffer.from(t.message).toString("hex"),encoding:"hex"}:t.message.startsWith("0x")?{message:t.message,encoding:"hex"}:{message:t.message,encoding:"utf-8"},{...i,method:e,params:r};case"eth_signTypedData_v4":return{...i,method:e,params:{typed_data:{domain:t.typedData.domain,types:t.typedData.types,message:t.typedData.message,primary_type:t.typedData.primaryType}}};case"eth_sendTransaction":return{...i,method:e,caip2:a.caip2,params:{transaction:{from:t.transaction.from,to:t.transaction.to,nonce:t.transaction.nonce,chain_id:t.transaction.chainId,data:t.transaction.data,value:t.transaction.value,type:t.transaction.type,gas_limit:t.transaction.gasLimit,gas_price:t.transaction.gasPrice,max_fee_per_gas:t.transaction.maxFeePerGas,max_priority_fee_per_gas:t.transaction.maxPriorityFeePerGas}}};default:throw Error(`Unsupported method: ${e}`)}}(e),r=z(e),n=b({method:"POST",url:`${this.api.baseURL}${t}`,body:i,appId:this.appId,idempotencyKeyHeader:r,authorizationPrivateKey:this.authorizationPrivateKey}),{data:s}=await this.api.post(t,i,{headers:{...n,...r}});return await async function(a,e){switch(e.method){case"signMessage":return{method:e.method,data:{signature:Buffer.from(e.data.signature,"base64")}};case"signTransaction":let t,i=a.params.transaction,r=Buffer.from(e.data.signed_transaction,"base64"),{Transaction:n,VersionedTransaction:s}=await import("@solana/web3.js");return t="version"in i?s.deserialize(r):n.from(r),{method:e.method,data:{signedTransaction:t}};case"signAndSendTransaction":if(e.data)return{method:e.method,data:{transactionId:e.data.transaction_id,hash:e.data.hash,caip2:e.data.caip2}};if(e.error)return{method:e.method,error:{code:e.error.code,message:e.error.message}};throw Error("Unexpected API response to signAndSendTransaction");case"eth_signTransaction":return{method:e.method,data:{signedTransaction:e.data.signed_transaction,encoding:e.data.encoding}};case"eth_sendTransaction":if(e.data)return{method:e.method,data:{transactionId:e.data.transaction_id,hash:e.data.hash,caip2:e.data.caip2}};if(e.error)return{method:e.method,error:{code:e.error.code,message:e.error.message}};throw Error("Unexpected API response to eth_sendTransaction");case"personal_sign":case"eth_signTypedData_v4":return{method:e.method,data:{signature:e.data.signature,encoding:e.data.encoding}};default:throw Error("Unsupported method")}}(e,s)}constructor({appId:a,api:e,authorizationPrivateKey:t}){Object.defineProperty(this,A,{value:D}),this.authorizationPrivateKey=null,this.api=e,t&&(this.authorizationPrivateKey=v(t)),this.appId=a,this.ethereum=new w({appId:a,api:e,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new f({appId:a,api:e,authorizationPrivateKey:this.authorizationPrivateKey})}}function D({path:a,body:e,idempotencyKey:t,method:i}){let r=z({idempotencyKey:t}),n={...r};if(this.authorizationPrivateKey){let t=K({method:i,url:`${this.api.baseURL}${a}`,body:e,appId:this.appId,idempotencyKeyHeader:r,authorizationPrivateKey:this.authorizationPrivateKey});void 0!==t&&(n["privy-authorization-signature"]=t)}return n}function j({input:a,authorizationPrivateKey:e}){let t;try{t=v(e)}catch(a){throw Error("Invalid authorization key format. Expected Privy-specific Authorization private key (wallet-auth:...)")}return K({method:a.method,url:a.url,body:a.body,appId:a.headers["privy-app-id"],idempotencyKeyHeader:a.headers["privy-idempotency-key"]?{"privy-idempotency-key":a.headers["privy-idempotency-key"]}:void 0,authorizationPrivateKey:t})}function H({input:a}){return x({method:a.method,body:a.body,url:a.url,appId:a.headers["privy-app-id"],idempotencyKeyHeader:a.headers["privy-idempotency-key"]?{"privy-idempotency-key":a.headers["privy-idempotency-key"]}:void 0})}export{E as WalletApi,H as formatRequestForAuthorizationSignature,j as generateAuthorizationSignature};
