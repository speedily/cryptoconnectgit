"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openseaActionProvider = exports.OpenseaActionProvider = void 0;
const zod_1 = require("zod");
const actionProvider_1 = require("../actionProvider");
const actionDecorator_1 = require("../actionDecorator");
const schemas_1 = require("./schemas");
const opensea_js_1 = require("opensea-js");
const network_1 = require("../../network");
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
/**
 * OpenseaActionProvider is an action provider for OpenSea marketplace interactions.
 */
class OpenseaActionProvider extends actionProvider_1.ActionProvider {
    /**
     * Constructor for the OpenseaActionProvider class.
     *
     * @param config - The configuration options for the OpenseaActionProvider.
     */
    constructor(config = {}) {
        super("opensea", []);
        /**
         * Checks if the Opensea action provider supports the given network.
         *
         * @param network - The network to check.
         * @returns True if the Opensea action provider supports the network, false otherwise.
         */
        this.supportsNetwork = (network) => network.chainId !== undefined && utils_1.supportedChains[network.chainId] !== undefined;
        const apiKey = config.apiKey || process.env.OPENSEA_API_KEY;
        if (!apiKey) {
            throw new Error("OPENSEA_API_KEY is not configured.");
        }
        this.apiKey = apiKey;
        const chainId = network_1.NETWORK_ID_TO_CHAIN_ID[config.networkId || "base-sepolia"];
        const provider = ethers_1.ethers.getDefaultProvider(parseInt(chainId));
        const walletWithProvider = new ethers_1.Wallet(config.privateKey, provider);
        this.walletWithProvider = walletWithProvider;
        const openseaSDK = new opensea_js_1.OpenSeaSDK(walletWithProvider, {
            chain: (0, utils_1.chainIdToOpenseaChain)(chainId),
            apiKey: this.apiKey,
        });
        this.openseaSDK = openseaSDK;
        this.openseaBaseUrl = this.openseaSDK.api.apiBaseUrl.replace("-api", "").replace("api", "");
    }
    /**
     * Lists an NFT for sale on OpenSea.
     *
     * @param args - The input arguments for the action.
     * @returns A message containing the listing details.
     */
    async listNft(args) {
        try {
            const expirationTime = Math.round(Date.now() / 1000 + args.expirationDays * 24 * 60 * 60);
            await this.openseaSDK.createListing({
                asset: {
                    tokenId: args.tokenId,
                    tokenAddress: args.contractAddress,
                },
                startAmount: args.price,
                quantity: 1,
                paymentTokenAddress: "0x0000000000000000000000000000000000000000", // ETH
                expirationTime,
                accountAddress: this.walletWithProvider.address,
            });
            const listingLink = `${this.openseaBaseUrl}/assets/${this.openseaSDK.chain}/${args.contractAddress}/${args.tokenId}`;
            return `Successfully listed NFT ${args.contractAddress} token ${args.tokenId} for ${args.price} ETH, expiring in ${args.expirationDays} days. Listing on OpenSea: ${listingLink}.`;
        }
        catch (error) {
            return `Error listing NFT ${args.contractAddress} token ${args.tokenId} for ${args.price} ETH using account ${this.walletWithProvider.address}: ${error}`;
        }
    }
    /**
     * Fetch NFTs of a specific wallet address.
     *
     * @param args - The input arguments for the action.
     * @returns A JSON string containing the NFTs or error message
     */
    async getNftsByAccount(args) {
        try {
            const address = args.accountAddress || this.walletWithProvider.address;
            const { nfts } = await this.openseaSDK.api.getNFTsByAccount(address);
            return JSON.stringify(nfts);
        }
        catch (error) {
            const address = args.accountAddress || this.walletWithProvider.address;
            return `Error fetching NFTs for account ${address}: ${error}`;
        }
    }
}
exports.OpenseaActionProvider = OpenseaActionProvider;
__decorate([
    (0, actionDecorator_1.CreateAction)({
        name: "list_nft",
        description: `
This tool will list an NFT for sale on the OpenSea marketplace. 
EVM networks are supported on mainnet and testnets.

It takes the following inputs:
- contractAddress: The NFT contract address to list
- tokenId: The ID of the NFT to list
- price: The price in ETH for which the NFT will be listed
- expirationDays: (Optional) Number of days the listing should be active for (default: 90)

Important notes:
- The wallet must own the NFT
- Price is in ETH (e.g., 1.5 for 1.5 ETH). This is the amount the seller will receive if the NFT is sold. It is not required to have this amount in the wallet.
- Listing the NFT requires approval for OpenSea to manage the entire NFT collection:  
  - If the collection is not already approved, an onchain transaction is required, which will incur gas fees.  
  - If already approved, listing is gasless and does not require any onchain transaction. 
  - EVM networks are supported on mainnet and testnets, for example: base-mainnet and base-sepolia.
  `,
        schema: schemas_1.ListNftSchema,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [void 0]),
    __metadata("design:returntype", Promise)
], OpenseaActionProvider.prototype, "listNft", null);
__decorate([
    (0, actionDecorator_1.CreateAction)({
        name: "get_nfts_by_account",
        description: `
This tool will fetch NFTs owned by a specific wallet address on OpenSea.

It takes the following inputs:
- accountAddress: (Optional) The wallet address to fetch NFTs for. If not provided, uses the connected wallet address.

The tool will return a JSON string containing the NFTs owned by the specified address.
    `,
        schema: schemas_1.GetNftsByAccountSchema,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [void 0]),
    __metadata("design:returntype", Promise)
], OpenseaActionProvider.prototype, "getNftsByAccount", null);
const openseaActionProvider = (config) => new OpenseaActionProvider(config);
exports.openseaActionProvider = openseaActionProvider;
