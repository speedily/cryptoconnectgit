import { maxUint256, parseAbi, } from "viem";
import { simulateDepositTx } from "./simulateDepositTx.js";
import { simulateApproveTx } from "./simulateApproveTx.js";
import { waitForDepositTx } from "./waitForDepositTx.js";
import { parseFillLogs, waitForFillTx } from "./waitForFillTx.js";
import { parseDepositLogs } from "./getDepositFromLogs.js";
/**
 * Executes a quote by:
 * 1. Approving the SpokePool contract if necessary
 * 2. Depositing the input token on the origin chain
 * 3. Waiting for the deposit to be filled on the destination chain
 * @param params - See {@link ExecuteQuoteParams}.
 * @returns The deposit ID and receipts for the deposit and fill transactions.
 * @public
 */
export async function executeQuote(params) {
    const { integratorId, deposit, walletClient, originClient, destinationClient, skipAllowanceCheck, infiniteApproval, throwOnError = true, forceOriginChain, onProgress, logger, } = params;
    const onProgressHandler = onProgress ||
        ((progress) => defaultProgressHandler(progress, logger));
    let txRequest;
    let currentTransactionProgress = {
        status: "idle",
        step: "approve",
    };
    let currentProgressMeta;
    try {
        const account = walletClient.account;
        if (!account) {
            throw new Error("Wallet account has to be set");
        }
        if (forceOriginChain) {
            await walletClient.switchChain({
                id: deposit.originChainId,
            });
        }
        const connectedChainId = await walletClient.getChainId();
        if (connectedChainId !== deposit.originChainId) {
            throw new Error(`Connected chain ${connectedChainId} does not match 'originChainId' ${deposit.originChainId}`);
        }
        const { inputToken, inputAmount, spokePoolAddress } = deposit;
        // Handle token approval if necessary. This will:
        // 1. Check if the allowance is sufficient for SpokePool
        // 2. If not, simulate an `approve` transaction
        // 3. If successful, execute the `approve` transaction
        if (!skipAllowanceCheck && !deposit.isNative) {
            const allowance = await originClient.readContract({
                address: inputToken,
                abi: parseAbi([
                    "function allowance(address owner, address spender) public view returns (uint256)",
                ]),
                functionName: "allowance",
                args: [account.address, spokePoolAddress],
            });
            logger?.debug("Allowance", {
                allowance,
                owner: account.address,
                spender: spokePoolAddress,
                inputToken,
            });
            if (BigInt(inputAmount) > allowance) {
                const approvalAmount = infiniteApproval
                    ? maxUint256
                    : BigInt(inputAmount);
                currentProgressMeta = {
                    approvalAmount,
                    spender: spokePoolAddress,
                };
                currentTransactionProgress = {
                    step: "approve",
                    status: "simulationPending",
                    meta: currentProgressMeta,
                };
                onProgressHandler(currentTransactionProgress);
                const { request } = await simulateApproveTx({
                    walletClient,
                    publicClient: originClient,
                    spender: spokePoolAddress,
                    approvalAmount,
                    tokenAddress: inputToken,
                });
                txRequest = request;
                currentTransactionProgress = {
                    ...currentTransactionProgress,
                    status: "simulationSuccess",
                    txRequest: request,
                };
                onProgressHandler(currentTransactionProgress);
                const approveTxHash = await walletClient.writeContract({
                    account,
                    ...txRequest,
                });
                currentTransactionProgress = {
                    ...currentTransactionProgress,
                    status: "txPending",
                    txHash: approveTxHash,
                };
                onProgressHandler(currentTransactionProgress);
                const approveTxReceipt = await originClient.waitForTransactionReceipt({
                    hash: approveTxHash,
                });
                currentTransactionProgress = {
                    ...currentTransactionProgress,
                    status: "txSuccess",
                    txReceipt: approveTxReceipt,
                };
                onProgressHandler(currentTransactionProgress);
            }
        }
        // Handle deposit transaction on SpokePool:
        // 1. Simulate the deposit transaction
        // 2. If successful, execute the deposit transaction
        // 3. Wait for the transaction to be mined
        currentProgressMeta = {
            deposit,
        };
        currentTransactionProgress = {
            step: "deposit",
            status: "simulationPending",
            meta: currentProgressMeta,
        };
        onProgressHandler(currentTransactionProgress);
        const { request: _request } = await simulateDepositTx({
            walletClient,
            publicClient: originClient,
            deposit,
            integratorId,
            logger,
        });
        txRequest = _request;
        currentTransactionProgress = {
            ...currentTransactionProgress,
            status: "simulationSuccess",
            txRequest: _request,
        };
        onProgressHandler(currentTransactionProgress);
        const depositTxHash = await walletClient.writeContract({
            account,
            ...txRequest,
        });
        currentTransactionProgress = {
            ...currentTransactionProgress,
            status: "txPending",
            txHash: depositTxHash,
        };
        onProgressHandler(currentTransactionProgress);
        const destinationBlock = await destinationClient.getBlockNumber();
        const { depositId, depositTxReceipt } = await waitForDepositTx({
            originChainId: deposit.originChainId,
            transactionHash: depositTxHash,
            publicClient: originClient,
        });
        const depositLog = parseDepositLogs(depositTxReceipt.logs);
        currentTransactionProgress = {
            ...currentTransactionProgress,
            status: "txSuccess",
            txReceipt: depositTxReceipt,
            depositId,
            depositLog,
        };
        onProgressHandler(currentTransactionProgress);
        // After successful deposit, wait for fill
        currentProgressMeta = {
            depositId,
            deposit,
        };
        currentTransactionProgress = {
            step: "fill",
            status: "txPending",
            meta: currentProgressMeta,
        };
        onProgressHandler(currentTransactionProgress);
        const { fillTxReceipt, fillTxTimestamp, actionSuccess } = await waitForFillTx({
            deposit,
            depositId,
            depositTxHash,
            destinationChainClient: destinationClient,
            fromBlock: destinationBlock - 100n, // TODO: use dynamic block buffer based chain
        });
        const fillLog = parseFillLogs(fillTxReceipt.logs);
        currentTransactionProgress = {
            ...currentTransactionProgress,
            status: "txSuccess",
            txReceipt: fillTxReceipt,
            fillTxTimestamp,
            actionSuccess,
            fillLog,
        };
        onProgressHandler(currentTransactionProgress);
        return { depositId, depositTxReceipt, fillTxReceipt };
    }
    catch (error) {
        const errorStatus = currentTransactionProgress.status === "txPending"
            ? "txError"
            : currentTransactionProgress.status === "simulationPending"
                ? "simulationError"
                : "error";
        onProgressHandler({
            ...currentTransactionProgress,
            status: errorStatus,
            error: error,
            meta: currentProgressMeta,
        });
        if (!throwOnError) {
            return { error };
        }
        throw error;
    }
}
function defaultProgressHandler(progress, logger) {
    if (!logger) {
        return;
    }
    logger.debug("Progress", progress);
}
//# sourceMappingURL=executeQuote.js.map