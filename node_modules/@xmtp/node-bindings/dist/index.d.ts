/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Client {
  accountIdentifier: Identifier
  inboxId(): string
  isRegistered(): boolean
  installationId(): string
  installationIdBytes(): Uint8Array
  /** The resulting vec will be the same length as the input and should be zipped for the results. */
  canMessage(accountIdentities: Array<Identifier>): Promise<Record<string, boolean>>
  registerIdentity(): Promise<void>
  conversations(): Conversations
  sendSyncRequest(): Promise<void>
  findInboxIdByIdentifier(identifier: Identifier): Promise<string | null>
  addressesFromInboxId(refreshFromNetwork: boolean, inboxIds: Array<string>): Promise<Array<InboxState>>
  syncPreferences(): Promise<number>
  apiStatistics(): ApiStats
  apiIdentityStatistics(): IdentityStats
  apiAggregateStatistics(): string
  uploadDebugArchive(serverUrl: string): Promise<string>
  setConsentStates(records: Array<Consent>): Promise<void>
  getConsentState(entityType: ConsentEntityType, entity: string): Promise<ConsentState>
  /**
   * Get the client's inbox state.
   *
   * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
   * Otherwise, the state will be read from the local database.
   */
  inboxState(refreshFromNetwork: boolean): Promise<InboxState>
  getLatestInboxState(inboxId: string): Promise<InboxState>
  /**
   * Get key package statuses for a list of installation IDs.
   *
   * Returns a JavaScript Object mapping installation ID strings to KeyPackageStatus objects.
   */
  getKeyPackageStatusesForInstallationIds(installationIds: Array<string>): Promise<Record<string, KeyPackageStatus>>
  createInboxSignatureText(): Promise<string | null>
  addIdentifierSignatureText(newIdentifier: Identifier): Promise<string>
  revokeIdentifierSignatureText(identifier: Identifier): Promise<string>
  revokeAllOtherInstallationsSignatureText(): Promise<string>
  revokeInstallationsSignatureText(installationIds: Array<Uint8Array>): Promise<string>
  changeRecoveryIdentifierSignatureText(newRecoveryIdentifier: Identifier): Promise<string>
  addEcdsaSignature(signatureType: SignatureRequestType, signatureBytes: Uint8Array): Promise<void>
  addPasskeySignature(signatureType: SignatureRequestType, signature: PasskeySignature): Promise<void>
  addScwSignature(signatureType: SignatureRequestType, signatureBytes: Uint8Array, chainId: bigint, blockNumber?: bigint | undefined | null): Promise<void>
  applySignatureRequests(): Promise<void>
  signWithInstallationKey(signatureText: string): Uint8Array
  verifySignedWithInstallationKey(signatureText: string, signatureBytes: Uint8Array): void
}

export declare class Conversation {
  id(): string
  send(encodedContent: EncodedContent): Promise<string>
  sendOptimistic(encodedContent: EncodedContent): string
  publishMessages(): Promise<void>
  sync(): Promise<void>
  findMessages(opts?: ListMessagesOptions | undefined | null): Promise<Array<Message>>
  findMessagesWithReactions(opts?: ListMessagesOptions | undefined | null): Promise<Array<MessageWithReactions>>
  processStreamedGroupMessage(envelopeBytes: Uint8Array): Promise<Message>
  listMembers(): Promise<Array<GroupMember>>
  adminList(): Array<string>
  superAdminList(): Array<string>
  isAdmin(inboxId: string): boolean
  isSuperAdmin(inboxId: string): boolean
  addMembers(accountIdentities: Array<Identifier>): Promise<void>
  addAdmin(inboxId: string): Promise<void>
  removeAdmin(inboxId: string): Promise<void>
  addSuperAdmin(inboxId: string): Promise<void>
  removeSuperAdmin(inboxId: string): Promise<void>
  groupPermissions(): GroupPermissions
  addMembersByInboxId(inboxIds: Array<string>): Promise<void>
  removeMembers(accountIdentities: Array<Identifier>): Promise<void>
  removeMembersByInboxId(inboxIds: Array<string>): Promise<void>
  updateGroupName(groupName: string): Promise<void>
  groupName(): string
  updateGroupImageUrlSquare(groupImageUrlSquare: string): Promise<void>
  groupImageUrlSquare(): string
  updateGroupDescription(groupDescription: string): Promise<void>
  groupDescription(): string
  stream(callback: (err: null | Error, result: Message | undefined) => void): StreamCloser
  createdAtNs(): number
  isActive(): boolean
  pausedForVersion(): string | null
  addedByInboxId(): string
  groupMetadata(): Promise<GroupMetadata>
  consentState(): ConsentState
  updateConsentState(state: ConsentState): void
  dmPeerInboxId(): string
  updatePermissionPolicy(permissionUpdateType: PermissionUpdateType, permissionPolicyOption: PermissionPolicy, metadataField?: MetadataField | undefined | null): Promise<void>
  updateMessageDisappearingSettings(settings: MessageDisappearingSettings): Promise<void>
  removeMessageDisappearingSettings(): Promise<void>
  messageDisappearingSettings(): MessageDisappearingSettings | null
  isMessageDisappearingEnabled(): boolean
  getHmacKeys(): Record<string, Array<HmacKey>>
  debugInfo(): Promise<ConversationDebugInfo>
  findDuplicateDms(): Promise<Array<Conversation>>
}

export declare class ConversationListItem {
  get conversation(): Conversation
  get lastMessage(): Message | null
}

export declare class Conversations {
  createGroupOptimistic(options?: CreateGroupOptions | undefined | null): Conversation
  createGroup(accountIdentities: Array<Identifier>, options?: CreateGroupOptions | undefined | null): Promise<Conversation>
  createGroupByInboxId(inboxIds: Array<string>, options?: CreateGroupOptions | undefined | null): Promise<Conversation>
  createDm(accountIdentity: Identifier, options?: CreateDmOptions | undefined | null): Promise<Conversation>
  createDmByInboxId(inboxId: string, options?: CreateDmOptions | undefined | null): Promise<Conversation>
  findGroupById(groupId: string): Conversation
  findDmByTargetInboxId(targetInboxId: string): Conversation
  findMessageById(messageId: string): Message
  processStreamedWelcomeMessage(envelopeBytes: Uint8Array): Promise<Conversation>
  sync(): Promise<void>
  syncAllConversations(consentStates?: Array<ConsentState> | undefined | null): Promise<bigint>
  list(opts?: ListConversationsOptions | undefined | null): Array<ConversationListItem>
  getHmacKeys(): Record<string, Array<HmacKey>>
  stream(callback: (err: Error | null, result: Conversation | undefined) => void, conversationType?: ConversationType): StreamCloser
  streamAllMessages(callback: (err: null | Error, result: Message | undefined) => void, conversationType?: ConversationType, consentStates?: ConsentState[]): StreamCloser
  streamConsent(callback: (err: null | Error, result: Consent[] | undefined) => void): StreamCloser
  streamPreferences(callback: (err: null | Error, result: any[] | undefined) => void): StreamCloser
}

export declare class GroupMember {
  inboxId: string
  accountIdentifiers: Array<Identifier>
  installationIds: Array<string>
  permissionLevel: PermissionLevel
  consentState: ConsentState
}

export declare class GroupMetadata {
  creatorInboxId(): string
  conversationType(): string
}

export declare class GroupPermissions {
  policyType(): GroupPermissionsOptions
  policySet(): PermissionPolicySet
}

export declare class StreamCloser {
  /**
   * Signal the stream to end
   * Does not wait for the stream to end.
   */
  end(): void
  /**
   * End the stream and `await` for it to shutdown
   * Returns the `Result` of the task.
   * End the stream and asynchronously wait for it to shutdown
   */
  endAndWait(): Promise<void>
  waitForReady(): Promise<void>
  /** Checks if this stream is closed */
  isClosed(): boolean
}

export interface ApiStats {
  uploadKeyPackage: bigint
  fetchKeyPackage: bigint
  sendGroupMessages: bigint
  sendWelcomeMessages: bigint
  queryGroupMessages: bigint
  queryWelcomeMessages: bigint
  subscribeMessages: bigint
  subscribeWelcomes: bigint
}

export interface Consent {
  entityType: ConsentEntityType
  state: ConsentState
  entity: string
}

export declare const enum ConsentEntityType {
  GroupId = 0,
  InboxId = 1
}

export declare const enum ConsentState {
  Unknown = 0,
  Allowed = 1,
  Denied = 2
}

export declare const enum ContentType {
  Unknown = 0,
  Text = 1,
  GroupMembershipChange = 2,
  GroupUpdated = 3,
  Reaction = 4,
  ReadReceipt = 5,
  Reply = 6,
  Attachment = 7,
  RemoteAttachment = 8,
  TransactionReference = 9
}

export interface ContentTypeId {
  authorityId: string
  typeId: string
  versionMajor: number
  versionMinor: number
}

export interface ConversationDebugInfo {
  epoch: bigint
  maybeForked: boolean
  forkDetails: string
}

export declare const enum ConversationType {
  Dm = 0,
  Group = 1,
  Sync = 2
}

/**
 * Create a client.
 *
 * Optionally specify a filter for the log level as a string.
 * It can be one of: `debug`, `info`, `warn`, `error` or 'off'.
 * By default, logging is disabled.
 */
export declare export declare function createClient(host: string, isSecure: boolean, dbPath: string | undefined | null, inboxId: string, accountIdentifier: Identifier, encryptionKey?: Uint8Array | undefined | null, deviceSyncServerUrl?: string | undefined | null, deviceSyncWorkerMode?: SyncWorkerMode | undefined | null, logOptions?: LogOptions | undefined | null): Promise<Client>

export interface CreateDmOptions {
  messageDisappearingSettings?: MessageDisappearingSettings
}

export interface CreateGroupOptions {
  permissions?: GroupPermissionsOptions
  groupName?: string
  groupImageUrlSquare?: string
  groupDescription?: string
  customPermissionPolicySet?: PermissionPolicySet
  messageDisappearingSettings?: MessageDisappearingSettings
}

export declare export declare function decodeMultiRemoteAttachment(bytes: Uint8Array): MultiRemoteAttachment

export declare export declare function decodeReaction(bytes: Uint8Array): Reaction

export declare const enum DeliveryStatus {
  Unpublished = 0,
  Published = 1,
  Failed = 2
}

export interface EncodedContent {
  type?: ContentTypeId
  parameters: Record<string, string>
  fallback?: string
  compression?: number
  content: Uint8Array
}

export declare export declare function encodeMultiRemoteAttachment(multiRemoteAttachment: MultiRemoteAttachment): Uint8Array

export declare export declare function encodeReaction(reaction: Reaction): Uint8Array

export declare export declare function generateInboxId(accountIdent: Identifier): string

export declare export declare function getInboxIdForIdentifier(host: string, isSecure: boolean, identifier: Identifier): Promise<string | null>

export declare const enum GroupMembershipState {
  Allowed = 0,
  Rejected = 1,
  Pending = 2,
  Restored = 3
}

export declare const enum GroupMessageKind {
  Application = 0,
  MembershipChange = 1
}

export declare const enum GroupPermissionsOptions {
  Default = 0,
  AdminOnly = 1,
  CustomPolicy = 2
}

export interface HmacKey {
  key: Uint8Array
  epoch: bigint
}

export interface Identifier {
  identifier: string
  identifierKind: IdentifierKind
}

export declare const enum IdentifierKind {
  Ethereum = 0,
  Passkey = 1
}

export interface IdentityStats {
  publishIdentityUpdate: bigint
  getIdentityUpdatesV2: bigint
  getInboxIds: bigint
  verifySmartContractWalletSignature: bigint
}

export interface InboxState {
  inboxId: string
  recoveryIdentifier: Identifier
  installations: Array<Installation>
  identifiers: Array<Identifier>
}

export interface Installation {
  bytes: Uint8Array
  clientTimestampNs?: bigint
  id: string
}

export declare export declare function isAddressAuthorized(host: string, inboxId: string, address: string): Promise<boolean>

export declare export declare function isInstallationAuthorized(host: string, inboxId: string, installationId: Uint8Array): Promise<boolean>

export interface KeyPackageStatus {
  lifetime?: Lifetime
  validationError?: string
}

export interface Lifetime {
  notBefore: bigint
  notAfter: bigint
}

export interface ListConversationsOptions {
  consentStates?: Array<ConsentState>
  conversationType?: ConversationType
  createdAfterNs?: number
  createdBeforeNs?: number
  includeDuplicateDms?: boolean
  limit?: number
}

export interface ListMessagesOptions {
  sentBeforeNs?: number
  sentAfterNs?: number
  limit?: number
  deliveryStatus?: DeliveryStatus
  direction?: SortDirection
  contentTypes?: Array<ContentType>
  kind?: GroupMessageKind
}

export declare const enum LogLevel {
  off = 'off',
  error = 'error',
  warn = 'warn',
  info = 'info',
  debug = 'debug',
  trace = 'trace'
}

/** Specify options for the logger */
export interface LogOptions {
  /**
   * enable structured JSON logging to stdout.Useful for third-party log viewers
   * an option so that it does not require being specified in js object.
   */
  structured?: boolean
  /** Filter logs by level */
  level?: LogLevel
}

export interface Message {
  id: string
  sentAtNs: number
  convoId: string
  senderInboxId: string
  content: EncodedContent
  kind: GroupMessageKind
  deliveryStatus: DeliveryStatus
}

export interface MessageDisappearingSettings {
  fromNs: number
  inNs: number
}

export interface MessageWithReactions {
  message: Message
  reactions: Array<Message>
}

export declare const enum MetadataField {
  GroupName = 0,
  Description = 1,
  ImageUrlSquare = 2
}

export interface MultiRemoteAttachment {
  attachments: Array<RemoteAttachmentInfo>
}

export interface PasskeySignature {
  publicKey: Array<number>
  signature: Array<number>
  authenticatorData: Array<number>
  clientDataJson: Array<number>
}

export declare const enum PermissionLevel {
  Member = 0,
  Admin = 1,
  SuperAdmin = 2
}

export declare const enum PermissionPolicy {
  Allow = 0,
  Deny = 1,
  Admin = 2,
  SuperAdmin = 3,
  DoesNotExist = 4,
  Other = 5
}

export interface PermissionPolicySet {
  addMemberPolicy: PermissionPolicy
  removeMemberPolicy: PermissionPolicy
  addAdminPolicy: PermissionPolicy
  removeAdminPolicy: PermissionPolicy
  updateGroupNamePolicy: PermissionPolicy
  updateGroupDescriptionPolicy: PermissionPolicy
  updateGroupImageUrlSquarePolicy: PermissionPolicy
  updateMessageDisappearingPolicy: PermissionPolicy
}

export declare const enum PermissionUpdateType {
  AddMember = 0,
  RemoveMember = 1,
  AddAdmin = 2,
  RemoveAdmin = 3,
  UpdateMetadata = 4
}

export interface Reaction {
  reference: string
  referenceInboxId: string
  action: ReactionAction
  content: string
  schema: ReactionSchema
}

export declare const enum ReactionAction {
  Unknown = 0,
  Added = 1,
  Removed = 2
}

export declare const enum ReactionSchema {
  Unknown = 0,
  Unicode = 1,
  Shortcode = 2,
  Custom = 3
}

export interface RemoteAttachmentInfo {
  secret: Uint8Array
  contentDigest: string
  nonce: Uint8Array
  scheme: string
  url: string
  salt: Uint8Array
  contentLength?: number
  filename?: string
}

export declare const enum SignatureRequestType {
  AddWallet = 0,
  CreateInbox = 1,
  RevokeWallet = 2,
  RevokeInstallations = 3,
  ChangeRecoveryIdentifier = 4
}

export declare const enum SortDirection {
  Ascending = 0,
  Descending = 1
}

export declare const enum SyncWorkerMode {
  enabled = 'enabled',
  disabled = 'disabled'
}

export declare export declare function verifySignedWithPublicKey(signatureText: string, signatureBytes: Uint8Array, publicKey: Uint8Array): void
