"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BankModule = void 0;
const stargate_1 = require("@cosmjs/stargate");
const base_1 = require("./base");
const query_1 = require("../types/generated/cosmos/bank/v1beta1/query");
const tx_1 = require("../types/generated/cosmos/bank/v1beta1/tx");
class BankModule extends base_1.BaseModule {
    constructor(queryClient, signingClient) {
        const protoQueryClient = (0, stargate_1.createProtobufRpcClient)(queryClient);
        super(new query_1.QueryClientImpl(protoQueryClient), signingClient);
    }
    // Query methods
    getBalance(address, denom) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.Balance({ address, denom });
        });
    }
    getAllBalances(address, resolveDenom, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.AllBalances({ address, resolveDenom, pagination });
        });
    }
    getSpendableBalances(address, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.SpendableBalances({ address, pagination });
        });
    }
    getSpendableBalanceByDenom(address, denom) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.SpendableBalanceByDenom({ address, denom });
        });
    }
    getTotalSupply(pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.TotalSupply({ pagination });
        });
    }
    getSupplyOf(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.SupplyOf({ denom });
        });
    }
    getDenomMetadata(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.DenomMetadata({ denom });
        });
    }
    getDenomMetadataByQueryString(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.DenomMetadataByQueryString({ denom });
        });
    }
    getDenomsMetadata(pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.DenomsMetadata({ pagination });
        });
    }
    getDenomOwners(denom, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.DenomOwners({ denom, pagination });
        });
    }
    getDenomOwnersByQuery(denom, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.DenomOwnersByQuery({ denom, pagination });
        });
    }
    getSendEnabled(denoms) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryService.SendEnabled({ denoms });
        });
    }
    // Tx methods
    send(fromAddress_1, toAddress_1, amount_1) {
        return __awaiter(this, arguments, void 0, function* (fromAddress, toAddress, amount, fee = "auto", memo = "") {
            const signingClient = this.assertSigningClient();
            const sendMsg = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                value: tx_1.MsgSend.fromPartial({
                    fromAddress,
                    toAddress,
                    amount,
                }),
            };
            return signingClient.signAndBroadcast(fromAddress, [sendMsg], fee, memo);
        });
    }
    multiSend(inputs_1, outputs_1) {
        return __awaiter(this, arguments, void 0, function* (inputs, outputs, fee = "auto", memo = "") {
            const signingClient = this.assertSigningClient();
            const multiSendMsg = {
                typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
                value: tx_1.MsgMultiSend.fromPartial({
                    inputs,
                    outputs,
                }),
            };
            return signingClient.signAndBroadcast(inputs[0].address, [multiSendMsg], fee, memo);
        });
    }
    burn(fromAddress_1, amount_1) {
        return __awaiter(this, arguments, void 0, function* (fromAddress, amount, fee = "auto", memo = "") {
            const signingClient = this.assertSigningClient();
            const burnMsg = {
                typeUrl: "/cosmos.bank.v1beta1.MsgBurn",
                value: tx_1.MsgBurn.fromPartial({
                    fromAddress,
                    amount,
                }),
            };
            return signingClient.signAndBroadcast(fromAddress, [burnMsg], fee, memo);
        });
    }
    updateParams(authority_1, params_1) {
        return __awaiter(this, arguments, void 0, function* (authority, params, fee = "auto", memo = "") {
            const signingClient = this.assertSigningClient();
            const updateParamsMsg = {
                typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
                value: tx_1.MsgUpdateParams.fromPartial({
                    authority,
                    params,
                }),
            };
            return signingClient.signAndBroadcast(authority, [updateParamsMsg], fee, memo);
        });
    }
    setSendEnabled(authority_1, sendEnabled_1, useDefaultFor_1) {
        return __awaiter(this, arguments, void 0, function* (authority, sendEnabled, useDefaultFor, fee = "auto", memo = "") {
            const signingClient = this.assertSigningClient();
            const setSendEnabledMsg = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
                value: tx_1.MsgSetSendEnabled.fromPartial({
                    authority,
                    sendEnabled,
                    useDefaultFor,
                }),
            };
            return signingClient.signAndBroadcast(authority, [setSendEnabledMsg], fee, memo);
        });
    }
}
exports.BankModule = BankModule;
