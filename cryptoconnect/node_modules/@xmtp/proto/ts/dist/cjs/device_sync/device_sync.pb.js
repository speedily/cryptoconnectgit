"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackupOptions = exports.BackupMetadataSave = exports.BackupElement = exports.backupElementSelectionToJSON = exports.backupElementSelectionFromJSON = exports.BackupElementSelection = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const group_backup_pb_1 = require("./group_backup.pb");
const message_backup_pb_1 = require("./message_backup.pb");
const consent_backup_pb_1 = require("./consent_backup.pb");
const event_backup_pb_1 = require("./event_backup.pb");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "xmtp.device_sync";
/** Definitions for backups */
/** Elements selected for backup */
var BackupElementSelection;
(function (BackupElementSelection) {
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_UNSPECIFIED"] = 0] = "BACKUP_ELEMENT_SELECTION_UNSPECIFIED";
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_MESSAGES"] = 1] = "BACKUP_ELEMENT_SELECTION_MESSAGES";
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_CONSENT"] = 2] = "BACKUP_ELEMENT_SELECTION_CONSENT";
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_EVENT"] = 3] = "BACKUP_ELEMENT_SELECTION_EVENT";
    BackupElementSelection[BackupElementSelection["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BackupElementSelection = exports.BackupElementSelection || (exports.BackupElementSelection = {}));
function backupElementSelectionFromJSON(object) {
    switch (object) {
        case 0:
        case "BACKUP_ELEMENT_SELECTION_UNSPECIFIED":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_UNSPECIFIED;
        case 1:
        case "BACKUP_ELEMENT_SELECTION_MESSAGES":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_MESSAGES;
        case 2:
        case "BACKUP_ELEMENT_SELECTION_CONSENT":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_CONSENT;
        case 3:
        case "BACKUP_ELEMENT_SELECTION_EVENT":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_EVENT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BackupElementSelection.UNRECOGNIZED;
    }
}
exports.backupElementSelectionFromJSON = backupElementSelectionFromJSON;
function backupElementSelectionToJSON(object) {
    switch (object) {
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_UNSPECIFIED:
            return "BACKUP_ELEMENT_SELECTION_UNSPECIFIED";
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_MESSAGES:
            return "BACKUP_ELEMENT_SELECTION_MESSAGES";
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_CONSENT:
            return "BACKUP_ELEMENT_SELECTION_CONSENT";
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_EVENT:
            return "BACKUP_ELEMENT_SELECTION_EVENT";
        case BackupElementSelection.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.backupElementSelectionToJSON = backupElementSelectionToJSON;
function createBaseBackupElement() {
    return {
        metadata: undefined,
        group: undefined,
        groupMessage: undefined,
        consent: undefined,
        event: undefined,
    };
}
exports.BackupElement = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.metadata !== undefined) {
            exports.BackupMetadataSave.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        if (message.group !== undefined) {
            group_backup_pb_1.GroupSave.encode(message.group, writer.uint32(18).fork()).ldelim();
        }
        if (message.groupMessage !== undefined) {
            message_backup_pb_1.GroupMessageSave.encode(message.groupMessage, writer.uint32(26).fork()).ldelim();
        }
        if (message.consent !== undefined) {
            consent_backup_pb_1.ConsentSave.encode(message.consent, writer.uint32(34).fork()).ldelim();
        }
        if (message.event !== undefined) {
            event_backup_pb_1.EventSave.encode(message.event, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackupElement();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.metadata = exports.BackupMetadataSave.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.group = group_backup_pb_1.GroupSave.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.groupMessage = message_backup_pb_1.GroupMessageSave.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.consent = consent_backup_pb_1.ConsentSave.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.event = event_backup_pb_1.EventSave.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata)
                ? exports.BackupMetadataSave.fromJSON(object.metadata)
                : undefined,
            group: isSet(object.group) ? group_backup_pb_1.GroupSave.fromJSON(object.group) : undefined,
            groupMessage: isSet(object.groupMessage)
                ? message_backup_pb_1.GroupMessageSave.fromJSON(object.groupMessage)
                : undefined,
            consent: isSet(object.consent)
                ? consent_backup_pb_1.ConsentSave.fromJSON(object.consent)
                : undefined,
            event: isSet(object.event) ? event_backup_pb_1.EventSave.fromJSON(object.event) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.metadata !== undefined &&
            (obj.metadata = message.metadata
                ? exports.BackupMetadataSave.toJSON(message.metadata)
                : undefined);
        message.group !== undefined &&
            (obj.group = message.group ? group_backup_pb_1.GroupSave.toJSON(message.group) : undefined);
        message.groupMessage !== undefined &&
            (obj.groupMessage = message.groupMessage
                ? message_backup_pb_1.GroupMessageSave.toJSON(message.groupMessage)
                : undefined);
        message.consent !== undefined &&
            (obj.consent = message.consent
                ? consent_backup_pb_1.ConsentSave.toJSON(message.consent)
                : undefined);
        message.event !== undefined &&
            (obj.event = message.event ? event_backup_pb_1.EventSave.toJSON(message.event) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBackupElement();
        message.metadata =
            object.metadata !== undefined && object.metadata !== null
                ? exports.BackupMetadataSave.fromPartial(object.metadata)
                : undefined;
        message.group =
            object.group !== undefined && object.group !== null
                ? group_backup_pb_1.GroupSave.fromPartial(object.group)
                : undefined;
        message.groupMessage =
            object.groupMessage !== undefined && object.groupMessage !== null
                ? message_backup_pb_1.GroupMessageSave.fromPartial(object.groupMessage)
                : undefined;
        message.consent =
            object.consent !== undefined && object.consent !== null
                ? consent_backup_pb_1.ConsentSave.fromPartial(object.consent)
                : undefined;
        message.event =
            object.event !== undefined && object.event !== null
                ? event_backup_pb_1.EventSave.fromPartial(object.event)
                : undefined;
        return message;
    },
};
function createBaseBackupMetadataSave() {
    return {
        elements: [],
        exportedAtNs: long_1.default.ZERO,
        startNs: undefined,
        endNs: undefined,
    };
}
exports.BackupMetadataSave = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(18).fork();
        for (const v of message.elements) {
            writer.int32(v);
        }
        writer.ldelim();
        if (!message.exportedAtNs.isZero()) {
            writer.uint32(24).int64(message.exportedAtNs);
        }
        if (message.startNs !== undefined) {
            writer.uint32(32).int64(message.startNs);
        }
        if (message.endNs !== undefined) {
            writer.uint32(40).int64(message.endNs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackupMetadataSave();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.elements.push(reader.int32());
                        }
                    }
                    else {
                        message.elements.push(reader.int32());
                    }
                    break;
                case 3:
                    message.exportedAtNs = reader.int64();
                    break;
                case 4:
                    message.startNs = reader.int64();
                    break;
                case 5:
                    message.endNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            elements: Array.isArray(object === null || object === void 0 ? void 0 : object.elements)
                ? object.elements.map((e) => backupElementSelectionFromJSON(e))
                : [],
            exportedAtNs: isSet(object.exportedAtNs)
                ? long_1.default.fromValue(object.exportedAtNs)
                : long_1.default.ZERO,
            startNs: isSet(object.startNs)
                ? long_1.default.fromValue(object.startNs)
                : undefined,
            endNs: isSet(object.endNs) ? long_1.default.fromValue(object.endNs) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.elements) {
            obj.elements = message.elements.map((e) => backupElementSelectionToJSON(e));
        }
        else {
            obj.elements = [];
        }
        message.exportedAtNs !== undefined &&
            (obj.exportedAtNs = (message.exportedAtNs || long_1.default.ZERO).toString());
        message.startNs !== undefined &&
            (obj.startNs = (message.startNs || undefined).toString());
        message.endNs !== undefined &&
            (obj.endNs = (message.endNs || undefined).toString());
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBackupMetadataSave();
        message.elements = ((_a = object.elements) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.exportedAtNs =
            object.exportedAtNs !== undefined && object.exportedAtNs !== null
                ? long_1.default.fromValue(object.exportedAtNs)
                : long_1.default.ZERO;
        message.startNs =
            object.startNs !== undefined && object.startNs !== null
                ? long_1.default.fromValue(object.startNs)
                : undefined;
        message.endNs =
            object.endNs !== undefined && object.endNs !== null
                ? long_1.default.fromValue(object.endNs)
                : undefined;
        return message;
    },
};
function createBaseBackupOptions() {
    return { elements: [], startNs: undefined, endNs: undefined };
}
exports.BackupOptions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.elements) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.startNs !== undefined) {
            writer.uint32(16).int64(message.startNs);
        }
        if (message.endNs !== undefined) {
            writer.uint32(24).int64(message.endNs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackupOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.elements.push(reader.int32());
                        }
                    }
                    else {
                        message.elements.push(reader.int32());
                    }
                    break;
                case 2:
                    message.startNs = reader.int64();
                    break;
                case 3:
                    message.endNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            elements: Array.isArray(object === null || object === void 0 ? void 0 : object.elements)
                ? object.elements.map((e) => backupElementSelectionFromJSON(e))
                : [],
            startNs: isSet(object.startNs)
                ? long_1.default.fromValue(object.startNs)
                : undefined,
            endNs: isSet(object.endNs) ? long_1.default.fromValue(object.endNs) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.elements) {
            obj.elements = message.elements.map((e) => backupElementSelectionToJSON(e));
        }
        else {
            obj.elements = [];
        }
        message.startNs !== undefined &&
            (obj.startNs = (message.startNs || undefined).toString());
        message.endNs !== undefined &&
            (obj.endNs = (message.endNs || undefined).toString());
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBackupOptions();
        message.elements = ((_a = object.elements) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.startNs =
            object.startNs !== undefined && object.startNs !== null
                ? long_1.default.fromValue(object.startNs)
                : undefined;
        message.endNs =
            object.endNs !== undefined && object.endNs !== null
                ? long_1.default.fromValue(object.endNs)
                : undefined;
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=device_sync.pb.js.map