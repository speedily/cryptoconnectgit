/* eslint-disable */
import Long from "long";
import { GroupSave } from "./group_backup.pb";
import { GroupMessageSave } from "./message_backup.pb";
import { ConsentSave } from "./consent_backup.pb";
import { EventSave } from "./event_backup.pb";
import _m0 from "protobufjs/minimal";
export const protobufPackage = "xmtp.device_sync";
/** Definitions for backups */
/** Elements selected for backup */
export var BackupElementSelection;
(function (BackupElementSelection) {
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_UNSPECIFIED"] = 0] = "BACKUP_ELEMENT_SELECTION_UNSPECIFIED";
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_MESSAGES"] = 1] = "BACKUP_ELEMENT_SELECTION_MESSAGES";
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_CONSENT"] = 2] = "BACKUP_ELEMENT_SELECTION_CONSENT";
    BackupElementSelection[BackupElementSelection["BACKUP_ELEMENT_SELECTION_EVENT"] = 3] = "BACKUP_ELEMENT_SELECTION_EVENT";
    BackupElementSelection[BackupElementSelection["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BackupElementSelection || (BackupElementSelection = {}));
export function backupElementSelectionFromJSON(object) {
    switch (object) {
        case 0:
        case "BACKUP_ELEMENT_SELECTION_UNSPECIFIED":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_UNSPECIFIED;
        case 1:
        case "BACKUP_ELEMENT_SELECTION_MESSAGES":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_MESSAGES;
        case 2:
        case "BACKUP_ELEMENT_SELECTION_CONSENT":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_CONSENT;
        case 3:
        case "BACKUP_ELEMENT_SELECTION_EVENT":
            return BackupElementSelection.BACKUP_ELEMENT_SELECTION_EVENT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BackupElementSelection.UNRECOGNIZED;
    }
}
export function backupElementSelectionToJSON(object) {
    switch (object) {
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_UNSPECIFIED:
            return "BACKUP_ELEMENT_SELECTION_UNSPECIFIED";
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_MESSAGES:
            return "BACKUP_ELEMENT_SELECTION_MESSAGES";
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_CONSENT:
            return "BACKUP_ELEMENT_SELECTION_CONSENT";
        case BackupElementSelection.BACKUP_ELEMENT_SELECTION_EVENT:
            return "BACKUP_ELEMENT_SELECTION_EVENT";
        case BackupElementSelection.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseBackupElement() {
    return {
        metadata: undefined,
        group: undefined,
        groupMessage: undefined,
        consent: undefined,
        event: undefined,
    };
}
export const BackupElement = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.metadata !== undefined) {
            BackupMetadataSave.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        if (message.group !== undefined) {
            GroupSave.encode(message.group, writer.uint32(18).fork()).ldelim();
        }
        if (message.groupMessage !== undefined) {
            GroupMessageSave.encode(message.groupMessage, writer.uint32(26).fork()).ldelim();
        }
        if (message.consent !== undefined) {
            ConsentSave.encode(message.consent, writer.uint32(34).fork()).ldelim();
        }
        if (message.event !== undefined) {
            EventSave.encode(message.event, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackupElement();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.metadata = BackupMetadataSave.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.group = GroupSave.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.groupMessage = GroupMessageSave.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.consent = ConsentSave.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.event = EventSave.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata)
                ? BackupMetadataSave.fromJSON(object.metadata)
                : undefined,
            group: isSet(object.group) ? GroupSave.fromJSON(object.group) : undefined,
            groupMessage: isSet(object.groupMessage)
                ? GroupMessageSave.fromJSON(object.groupMessage)
                : undefined,
            consent: isSet(object.consent)
                ? ConsentSave.fromJSON(object.consent)
                : undefined,
            event: isSet(object.event) ? EventSave.fromJSON(object.event) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.metadata !== undefined &&
            (obj.metadata = message.metadata
                ? BackupMetadataSave.toJSON(message.metadata)
                : undefined);
        message.group !== undefined &&
            (obj.group = message.group ? GroupSave.toJSON(message.group) : undefined);
        message.groupMessage !== undefined &&
            (obj.groupMessage = message.groupMessage
                ? GroupMessageSave.toJSON(message.groupMessage)
                : undefined);
        message.consent !== undefined &&
            (obj.consent = message.consent
                ? ConsentSave.toJSON(message.consent)
                : undefined);
        message.event !== undefined &&
            (obj.event = message.event ? EventSave.toJSON(message.event) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBackupElement();
        message.metadata =
            object.metadata !== undefined && object.metadata !== null
                ? BackupMetadataSave.fromPartial(object.metadata)
                : undefined;
        message.group =
            object.group !== undefined && object.group !== null
                ? GroupSave.fromPartial(object.group)
                : undefined;
        message.groupMessage =
            object.groupMessage !== undefined && object.groupMessage !== null
                ? GroupMessageSave.fromPartial(object.groupMessage)
                : undefined;
        message.consent =
            object.consent !== undefined && object.consent !== null
                ? ConsentSave.fromPartial(object.consent)
                : undefined;
        message.event =
            object.event !== undefined && object.event !== null
                ? EventSave.fromPartial(object.event)
                : undefined;
        return message;
    },
};
function createBaseBackupMetadataSave() {
    return {
        elements: [],
        exportedAtNs: Long.ZERO,
        startNs: undefined,
        endNs: undefined,
    };
}
export const BackupMetadataSave = {
    encode(message, writer = _m0.Writer.create()) {
        writer.uint32(18).fork();
        for (const v of message.elements) {
            writer.int32(v);
        }
        writer.ldelim();
        if (!message.exportedAtNs.isZero()) {
            writer.uint32(24).int64(message.exportedAtNs);
        }
        if (message.startNs !== undefined) {
            writer.uint32(32).int64(message.startNs);
        }
        if (message.endNs !== undefined) {
            writer.uint32(40).int64(message.endNs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackupMetadataSave();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.elements.push(reader.int32());
                        }
                    }
                    else {
                        message.elements.push(reader.int32());
                    }
                    break;
                case 3:
                    message.exportedAtNs = reader.int64();
                    break;
                case 4:
                    message.startNs = reader.int64();
                    break;
                case 5:
                    message.endNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            elements: Array.isArray(object === null || object === void 0 ? void 0 : object.elements)
                ? object.elements.map((e) => backupElementSelectionFromJSON(e))
                : [],
            exportedAtNs: isSet(object.exportedAtNs)
                ? Long.fromValue(object.exportedAtNs)
                : Long.ZERO,
            startNs: isSet(object.startNs)
                ? Long.fromValue(object.startNs)
                : undefined,
            endNs: isSet(object.endNs) ? Long.fromValue(object.endNs) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.elements) {
            obj.elements = message.elements.map((e) => backupElementSelectionToJSON(e));
        }
        else {
            obj.elements = [];
        }
        message.exportedAtNs !== undefined &&
            (obj.exportedAtNs = (message.exportedAtNs || Long.ZERO).toString());
        message.startNs !== undefined &&
            (obj.startNs = (message.startNs || undefined).toString());
        message.endNs !== undefined &&
            (obj.endNs = (message.endNs || undefined).toString());
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBackupMetadataSave();
        message.elements = ((_a = object.elements) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.exportedAtNs =
            object.exportedAtNs !== undefined && object.exportedAtNs !== null
                ? Long.fromValue(object.exportedAtNs)
                : Long.ZERO;
        message.startNs =
            object.startNs !== undefined && object.startNs !== null
                ? Long.fromValue(object.startNs)
                : undefined;
        message.endNs =
            object.endNs !== undefined && object.endNs !== null
                ? Long.fromValue(object.endNs)
                : undefined;
        return message;
    },
};
function createBaseBackupOptions() {
    return { elements: [], startNs: undefined, endNs: undefined };
}
export const BackupOptions = {
    encode(message, writer = _m0.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.elements) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.startNs !== undefined) {
            writer.uint32(16).int64(message.startNs);
        }
        if (message.endNs !== undefined) {
            writer.uint32(24).int64(message.endNs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackupOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.elements.push(reader.int32());
                        }
                    }
                    else {
                        message.elements.push(reader.int32());
                    }
                    break;
                case 2:
                    message.startNs = reader.int64();
                    break;
                case 3:
                    message.endNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            elements: Array.isArray(object === null || object === void 0 ? void 0 : object.elements)
                ? object.elements.map((e) => backupElementSelectionFromJSON(e))
                : [],
            startNs: isSet(object.startNs)
                ? Long.fromValue(object.startNs)
                : undefined,
            endNs: isSet(object.endNs) ? Long.fromValue(object.endNs) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.elements) {
            obj.elements = message.elements.map((e) => backupElementSelectionToJSON(e));
        }
        else {
            obj.elements = [];
        }
        message.startNs !== undefined &&
            (obj.startNs = (message.startNs || undefined).toString());
        message.endNs !== undefined &&
            (obj.endNs = (message.endNs || undefined).toString());
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBackupOptions();
        message.elements = ((_a = object.elements) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.startNs =
            object.startNs !== undefined && object.startNs !== null
                ? Long.fromValue(object.startNs)
                : undefined;
        message.endNs =
            object.endNs !== undefined && object.endNs !== null
                ? Long.fromValue(object.endNs)
                : undefined;
        return message;
    },
};
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=device_sync.pb.js.map