/* eslint-disable */
import Long from "long";
import { Signature } from "./signature.pb";
import _m0 from "protobufjs/minimal";
export const protobufPackage = "xmtp.identity.associations";
/** Payloads to be signed for identity associations */
/** List of identity kinds */
export var IdentifierKind;
(function (IdentifierKind) {
    /** IDENTIFIER_KIND_UNSPECIFIED - Ethereum on old clients */
    IdentifierKind[IdentifierKind["IDENTIFIER_KIND_UNSPECIFIED"] = 0] = "IDENTIFIER_KIND_UNSPECIFIED";
    IdentifierKind[IdentifierKind["IDENTIFIER_KIND_ETHEREUM"] = 1] = "IDENTIFIER_KIND_ETHEREUM";
    IdentifierKind[IdentifierKind["IDENTIFIER_KIND_PASSKEY"] = 2] = "IDENTIFIER_KIND_PASSKEY";
    IdentifierKind[IdentifierKind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(IdentifierKind || (IdentifierKind = {}));
export function identifierKindFromJSON(object) {
    switch (object) {
        case 0:
        case "IDENTIFIER_KIND_UNSPECIFIED":
            return IdentifierKind.IDENTIFIER_KIND_UNSPECIFIED;
        case 1:
        case "IDENTIFIER_KIND_ETHEREUM":
            return IdentifierKind.IDENTIFIER_KIND_ETHEREUM;
        case 2:
        case "IDENTIFIER_KIND_PASSKEY":
            return IdentifierKind.IDENTIFIER_KIND_PASSKEY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return IdentifierKind.UNRECOGNIZED;
    }
}
export function identifierKindToJSON(object) {
    switch (object) {
        case IdentifierKind.IDENTIFIER_KIND_UNSPECIFIED:
            return "IDENTIFIER_KIND_UNSPECIFIED";
        case IdentifierKind.IDENTIFIER_KIND_ETHEREUM:
            return "IDENTIFIER_KIND_ETHEREUM";
        case IdentifierKind.IDENTIFIER_KIND_PASSKEY:
            return "IDENTIFIER_KIND_PASSKEY";
        case IdentifierKind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseMemberIdentifier() {
    return {
        ethereumAddress: undefined,
        installationPublicKey: undefined,
        passkey: undefined,
    };
}
export const MemberIdentifier = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.ethereumAddress !== undefined) {
            writer.uint32(10).string(message.ethereumAddress);
        }
        if (message.installationPublicKey !== undefined) {
            writer.uint32(18).bytes(message.installationPublicKey);
        }
        if (message.passkey !== undefined) {
            Passkey.encode(message.passkey, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMemberIdentifier();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ethereumAddress = reader.string();
                    break;
                case 2:
                    message.installationPublicKey = reader.bytes();
                    break;
                case 3:
                    message.passkey = Passkey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ethereumAddress: isSet(object.ethereumAddress)
                ? String(object.ethereumAddress)
                : undefined,
            installationPublicKey: isSet(object.installationPublicKey)
                ? bytesFromBase64(object.installationPublicKey)
                : undefined,
            passkey: isSet(object.passkey)
                ? Passkey.fromJSON(object.passkey)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.ethereumAddress !== undefined &&
            (obj.ethereumAddress = message.ethereumAddress);
        message.installationPublicKey !== undefined &&
            (obj.installationPublicKey =
                message.installationPublicKey !== undefined
                    ? base64FromBytes(message.installationPublicKey)
                    : undefined);
        message.passkey !== undefined &&
            (obj.passkey = message.passkey
                ? Passkey.toJSON(message.passkey)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMemberIdentifier();
        message.ethereumAddress = (_a = object.ethereumAddress) !== null && _a !== void 0 ? _a : undefined;
        message.installationPublicKey = (_b = object.installationPublicKey) !== null && _b !== void 0 ? _b : undefined;
        message.passkey =
            object.passkey !== undefined && object.passkey !== null
                ? Passkey.fromPartial(object.passkey)
                : undefined;
        return message;
    },
};
function createBasePasskey() {
    return { key: new Uint8Array(), relyingParty: undefined };
}
export const Passkey = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        if (message.relyingParty !== undefined) {
            writer.uint32(18).string(message.relyingParty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePasskey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.relyingParty = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
            relyingParty: isSet(object.relyingParty)
                ? String(object.relyingParty)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined &&
            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));
        message.relyingParty !== undefined &&
            (obj.relyingParty = message.relyingParty);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePasskey();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.relyingParty = (_b = object.relyingParty) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseMember() {
    return {
        identifier: undefined,
        addedByEntity: undefined,
        clientTimestampNs: undefined,
        addedOnChainId: undefined,
    };
}
export const Member = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.identifier !== undefined) {
            MemberIdentifier.encode(message.identifier, writer.uint32(10).fork()).ldelim();
        }
        if (message.addedByEntity !== undefined) {
            MemberIdentifier.encode(message.addedByEntity, writer.uint32(18).fork()).ldelim();
        }
        if (message.clientTimestampNs !== undefined) {
            writer.uint32(24).uint64(message.clientTimestampNs);
        }
        if (message.addedOnChainId !== undefined) {
            writer.uint32(32).uint64(message.addedOnChainId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMember();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.identifier = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.addedByEntity = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.clientTimestampNs = reader.uint64();
                    break;
                case 4:
                    message.addedOnChainId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            identifier: isSet(object.identifier)
                ? MemberIdentifier.fromJSON(object.identifier)
                : undefined,
            addedByEntity: isSet(object.addedByEntity)
                ? MemberIdentifier.fromJSON(object.addedByEntity)
                : undefined,
            clientTimestampNs: isSet(object.clientTimestampNs)
                ? Long.fromValue(object.clientTimestampNs)
                : undefined,
            addedOnChainId: isSet(object.addedOnChainId)
                ? Long.fromValue(object.addedOnChainId)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.identifier !== undefined &&
            (obj.identifier = message.identifier
                ? MemberIdentifier.toJSON(message.identifier)
                : undefined);
        message.addedByEntity !== undefined &&
            (obj.addedByEntity = message.addedByEntity
                ? MemberIdentifier.toJSON(message.addedByEntity)
                : undefined);
        message.clientTimestampNs !== undefined &&
            (obj.clientTimestampNs = (message.clientTimestampNs || undefined).toString());
        message.addedOnChainId !== undefined &&
            (obj.addedOnChainId = (message.addedOnChainId || undefined).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMember();
        message.identifier =
            object.identifier !== undefined && object.identifier !== null
                ? MemberIdentifier.fromPartial(object.identifier)
                : undefined;
        message.addedByEntity =
            object.addedByEntity !== undefined && object.addedByEntity !== null
                ? MemberIdentifier.fromPartial(object.addedByEntity)
                : undefined;
        message.clientTimestampNs =
            object.clientTimestampNs !== undefined &&
                object.clientTimestampNs !== null
                ? Long.fromValue(object.clientTimestampNs)
                : undefined;
        message.addedOnChainId =
            object.addedOnChainId !== undefined && object.addedOnChainId !== null
                ? Long.fromValue(object.addedOnChainId)
                : undefined;
        return message;
    },
};
function createBaseCreateInbox() {
    return {
        initialIdentifier: "",
        nonce: Long.UZERO,
        initialIdentifierSignature: undefined,
        initialIdentifierKind: 0,
        relyingParty: undefined,
    };
}
export const CreateInbox = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.initialIdentifier !== "") {
            writer.uint32(10).string(message.initialIdentifier);
        }
        if (!message.nonce.isZero()) {
            writer.uint32(16).uint64(message.nonce);
        }
        if (message.initialIdentifierSignature !== undefined) {
            Signature.encode(message.initialIdentifierSignature, writer.uint32(26).fork()).ldelim();
        }
        if (message.initialIdentifierKind !== 0) {
            writer.uint32(32).int32(message.initialIdentifierKind);
        }
        if (message.relyingParty !== undefined) {
            writer.uint32(42).string(message.relyingParty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateInbox();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.initialIdentifier = reader.string();
                    break;
                case 2:
                    message.nonce = reader.uint64();
                    break;
                case 3:
                    message.initialIdentifierSignature = Signature.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.initialIdentifierKind = reader.int32();
                    break;
                case 5:
                    message.relyingParty = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            initialIdentifier: isSet(object.initialIdentifier)
                ? String(object.initialIdentifier)
                : "",
            nonce: isSet(object.nonce) ? Long.fromValue(object.nonce) : Long.UZERO,
            initialIdentifierSignature: isSet(object.initialIdentifierSignature)
                ? Signature.fromJSON(object.initialIdentifierSignature)
                : undefined,
            initialIdentifierKind: isSet(object.initialIdentifierKind)
                ? identifierKindFromJSON(object.initialIdentifierKind)
                : 0,
            relyingParty: isSet(object.relyingParty)
                ? String(object.relyingParty)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.initialIdentifier !== undefined &&
            (obj.initialIdentifier = message.initialIdentifier);
        message.nonce !== undefined &&
            (obj.nonce = (message.nonce || Long.UZERO).toString());
        message.initialIdentifierSignature !== undefined &&
            (obj.initialIdentifierSignature = message.initialIdentifierSignature
                ? Signature.toJSON(message.initialIdentifierSignature)
                : undefined);
        message.initialIdentifierKind !== undefined &&
            (obj.initialIdentifierKind = identifierKindToJSON(message.initialIdentifierKind));
        message.relyingParty !== undefined &&
            (obj.relyingParty = message.relyingParty);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCreateInbox();
        message.initialIdentifier = (_a = object.initialIdentifier) !== null && _a !== void 0 ? _a : "";
        message.nonce =
            object.nonce !== undefined && object.nonce !== null
                ? Long.fromValue(object.nonce)
                : Long.UZERO;
        message.initialIdentifierSignature =
            object.initialIdentifierSignature !== undefined &&
                object.initialIdentifierSignature !== null
                ? Signature.fromPartial(object.initialIdentifierSignature)
                : undefined;
        message.initialIdentifierKind = (_b = object.initialIdentifierKind) !== null && _b !== void 0 ? _b : 0;
        message.relyingParty = (_c = object.relyingParty) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseAddAssociation() {
    return {
        newMemberIdentifier: undefined,
        existingMemberSignature: undefined,
        newMemberSignature: undefined,
        relyingParty: undefined,
    };
}
export const AddAssociation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.newMemberIdentifier !== undefined) {
            MemberIdentifier.encode(message.newMemberIdentifier, writer.uint32(10).fork()).ldelim();
        }
        if (message.existingMemberSignature !== undefined) {
            Signature.encode(message.existingMemberSignature, writer.uint32(18).fork()).ldelim();
        }
        if (message.newMemberSignature !== undefined) {
            Signature.encode(message.newMemberSignature, writer.uint32(26).fork()).ldelim();
        }
        if (message.relyingParty !== undefined) {
            writer.uint32(34).string(message.relyingParty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddAssociation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.newMemberIdentifier = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.existingMemberSignature = Signature.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.newMemberSignature = Signature.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.relyingParty = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            newMemberIdentifier: isSet(object.newMemberIdentifier)
                ? MemberIdentifier.fromJSON(object.newMemberIdentifier)
                : undefined,
            existingMemberSignature: isSet(object.existingMemberSignature)
                ? Signature.fromJSON(object.existingMemberSignature)
                : undefined,
            newMemberSignature: isSet(object.newMemberSignature)
                ? Signature.fromJSON(object.newMemberSignature)
                : undefined,
            relyingParty: isSet(object.relyingParty)
                ? String(object.relyingParty)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.newMemberIdentifier !== undefined &&
            (obj.newMemberIdentifier = message.newMemberIdentifier
                ? MemberIdentifier.toJSON(message.newMemberIdentifier)
                : undefined);
        message.existingMemberSignature !== undefined &&
            (obj.existingMemberSignature = message.existingMemberSignature
                ? Signature.toJSON(message.existingMemberSignature)
                : undefined);
        message.newMemberSignature !== undefined &&
            (obj.newMemberSignature = message.newMemberSignature
                ? Signature.toJSON(message.newMemberSignature)
                : undefined);
        message.relyingParty !== undefined &&
            (obj.relyingParty = message.relyingParty);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAddAssociation();
        message.newMemberIdentifier =
            object.newMemberIdentifier !== undefined &&
                object.newMemberIdentifier !== null
                ? MemberIdentifier.fromPartial(object.newMemberIdentifier)
                : undefined;
        message.existingMemberSignature =
            object.existingMemberSignature !== undefined &&
                object.existingMemberSignature !== null
                ? Signature.fromPartial(object.existingMemberSignature)
                : undefined;
        message.newMemberSignature =
            object.newMemberSignature !== undefined &&
                object.newMemberSignature !== null
                ? Signature.fromPartial(object.newMemberSignature)
                : undefined;
        message.relyingParty = (_a = object.relyingParty) !== null && _a !== void 0 ? _a : undefined;
        return message;
    },
};
function createBaseRevokeAssociation() {
    return { memberToRevoke: undefined, recoveryIdentifierSignature: undefined };
}
export const RevokeAssociation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.memberToRevoke !== undefined) {
            MemberIdentifier.encode(message.memberToRevoke, writer.uint32(10).fork()).ldelim();
        }
        if (message.recoveryIdentifierSignature !== undefined) {
            Signature.encode(message.recoveryIdentifierSignature, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeAssociation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.memberToRevoke = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.recoveryIdentifierSignature = Signature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            memberToRevoke: isSet(object.memberToRevoke)
                ? MemberIdentifier.fromJSON(object.memberToRevoke)
                : undefined,
            recoveryIdentifierSignature: isSet(object.recoveryIdentifierSignature)
                ? Signature.fromJSON(object.recoveryIdentifierSignature)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.memberToRevoke !== undefined &&
            (obj.memberToRevoke = message.memberToRevoke
                ? MemberIdentifier.toJSON(message.memberToRevoke)
                : undefined);
        message.recoveryIdentifierSignature !== undefined &&
            (obj.recoveryIdentifierSignature = message.recoveryIdentifierSignature
                ? Signature.toJSON(message.recoveryIdentifierSignature)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseRevokeAssociation();
        message.memberToRevoke =
            object.memberToRevoke !== undefined && object.memberToRevoke !== null
                ? MemberIdentifier.fromPartial(object.memberToRevoke)
                : undefined;
        message.recoveryIdentifierSignature =
            object.recoveryIdentifierSignature !== undefined &&
                object.recoveryIdentifierSignature !== null
                ? Signature.fromPartial(object.recoveryIdentifierSignature)
                : undefined;
        return message;
    },
};
function createBaseChangeRecoveryAddress() {
    return {
        newRecoveryIdentifier: "",
        existingRecoveryIdentifierSignature: undefined,
        newRecoveryIdentifierKind: 0,
        relyingParty: undefined,
    };
}
export const ChangeRecoveryAddress = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.newRecoveryIdentifier !== "") {
            writer.uint32(10).string(message.newRecoveryIdentifier);
        }
        if (message.existingRecoveryIdentifierSignature !== undefined) {
            Signature.encode(message.existingRecoveryIdentifierSignature, writer.uint32(18).fork()).ldelim();
        }
        if (message.newRecoveryIdentifierKind !== 0) {
            writer.uint32(24).int32(message.newRecoveryIdentifierKind);
        }
        if (message.relyingParty !== undefined) {
            writer.uint32(34).string(message.relyingParty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChangeRecoveryAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.newRecoveryIdentifier = reader.string();
                    break;
                case 2:
                    message.existingRecoveryIdentifierSignature = Signature.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.newRecoveryIdentifierKind = reader.int32();
                    break;
                case 4:
                    message.relyingParty = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            newRecoveryIdentifier: isSet(object.newRecoveryIdentifier)
                ? String(object.newRecoveryIdentifier)
                : "",
            existingRecoveryIdentifierSignature: isSet(object.existingRecoveryIdentifierSignature)
                ? Signature.fromJSON(object.existingRecoveryIdentifierSignature)
                : undefined,
            newRecoveryIdentifierKind: isSet(object.newRecoveryIdentifierKind)
                ? identifierKindFromJSON(object.newRecoveryIdentifierKind)
                : 0,
            relyingParty: isSet(object.relyingParty)
                ? String(object.relyingParty)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.newRecoveryIdentifier !== undefined &&
            (obj.newRecoveryIdentifier = message.newRecoveryIdentifier);
        message.existingRecoveryIdentifierSignature !== undefined &&
            (obj.existingRecoveryIdentifierSignature =
                message.existingRecoveryIdentifierSignature
                    ? Signature.toJSON(message.existingRecoveryIdentifierSignature)
                    : undefined);
        message.newRecoveryIdentifierKind !== undefined &&
            (obj.newRecoveryIdentifierKind = identifierKindToJSON(message.newRecoveryIdentifierKind));
        message.relyingParty !== undefined &&
            (obj.relyingParty = message.relyingParty);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseChangeRecoveryAddress();
        message.newRecoveryIdentifier = (_a = object.newRecoveryIdentifier) !== null && _a !== void 0 ? _a : "";
        message.existingRecoveryIdentifierSignature =
            object.existingRecoveryIdentifierSignature !== undefined &&
                object.existingRecoveryIdentifierSignature !== null
                ? Signature.fromPartial(object.existingRecoveryIdentifierSignature)
                : undefined;
        message.newRecoveryIdentifierKind = (_b = object.newRecoveryIdentifierKind) !== null && _b !== void 0 ? _b : 0;
        message.relyingParty = (_c = object.relyingParty) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseIdentityAction() {
    return {
        createInbox: undefined,
        add: undefined,
        revoke: undefined,
        changeRecoveryAddress: undefined,
    };
}
export const IdentityAction = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.createInbox !== undefined) {
            CreateInbox.encode(message.createInbox, writer.uint32(10).fork()).ldelim();
        }
        if (message.add !== undefined) {
            AddAssociation.encode(message.add, writer.uint32(18).fork()).ldelim();
        }
        if (message.revoke !== undefined) {
            RevokeAssociation.encode(message.revoke, writer.uint32(26).fork()).ldelim();
        }
        if (message.changeRecoveryAddress !== undefined) {
            ChangeRecoveryAddress.encode(message.changeRecoveryAddress, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentityAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.createInbox = CreateInbox.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.add = AddAssociation.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.revoke = RevokeAssociation.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.changeRecoveryAddress = ChangeRecoveryAddress.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            createInbox: isSet(object.createInbox)
                ? CreateInbox.fromJSON(object.createInbox)
                : undefined,
            add: isSet(object.add) ? AddAssociation.fromJSON(object.add) : undefined,
            revoke: isSet(object.revoke)
                ? RevokeAssociation.fromJSON(object.revoke)
                : undefined,
            changeRecoveryAddress: isSet(object.changeRecoveryAddress)
                ? ChangeRecoveryAddress.fromJSON(object.changeRecoveryAddress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.createInbox !== undefined &&
            (obj.createInbox = message.createInbox
                ? CreateInbox.toJSON(message.createInbox)
                : undefined);
        message.add !== undefined &&
            (obj.add = message.add ? AddAssociation.toJSON(message.add) : undefined);
        message.revoke !== undefined &&
            (obj.revoke = message.revoke
                ? RevokeAssociation.toJSON(message.revoke)
                : undefined);
        message.changeRecoveryAddress !== undefined &&
            (obj.changeRecoveryAddress = message.changeRecoveryAddress
                ? ChangeRecoveryAddress.toJSON(message.changeRecoveryAddress)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseIdentityAction();
        message.createInbox =
            object.createInbox !== undefined && object.createInbox !== null
                ? CreateInbox.fromPartial(object.createInbox)
                : undefined;
        message.add =
            object.add !== undefined && object.add !== null
                ? AddAssociation.fromPartial(object.add)
                : undefined;
        message.revoke =
            object.revoke !== undefined && object.revoke !== null
                ? RevokeAssociation.fromPartial(object.revoke)
                : undefined;
        message.changeRecoveryAddress =
            object.changeRecoveryAddress !== undefined &&
                object.changeRecoveryAddress !== null
                ? ChangeRecoveryAddress.fromPartial(object.changeRecoveryAddress)
                : undefined;
        return message;
    },
};
function createBaseIdentityUpdate() {
    return { actions: [], clientTimestampNs: Long.UZERO, inboxId: "" };
}
export const IdentityUpdate = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            IdentityAction.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (!message.clientTimestampNs.isZero()) {
            writer.uint32(16).uint64(message.clientTimestampNs);
        }
        if (message.inboxId !== "") {
            writer.uint32(26).string(message.inboxId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentityUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(IdentityAction.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.clientTimestampNs = reader.uint64();
                    break;
                case 3:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            actions: Array.isArray(object === null || object === void 0 ? void 0 : object.actions)
                ? object.actions.map((e) => IdentityAction.fromJSON(e))
                : [],
            clientTimestampNs: isSet(object.clientTimestampNs)
                ? Long.fromValue(object.clientTimestampNs)
                : Long.UZERO,
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actions) {
            obj.actions = message.actions.map((e) => e ? IdentityAction.toJSON(e) : undefined);
        }
        else {
            obj.actions = [];
        }
        message.clientTimestampNs !== undefined &&
            (obj.clientTimestampNs = (message.clientTimestampNs || Long.UZERO).toString());
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseIdentityUpdate();
        message.actions =
            ((_a = object.actions) === null || _a === void 0 ? void 0 : _a.map((e) => IdentityAction.fromPartial(e))) || [];
        message.clientTimestampNs =
            object.clientTimestampNs !== undefined &&
                object.clientTimestampNs !== null
                ? Long.fromValue(object.clientTimestampNs)
                : Long.UZERO;
        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMemberMap() {
    return { key: undefined, value: undefined };
}
export const MemberMap = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== undefined) {
            MemberIdentifier.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.value !== undefined) {
            Member.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMemberMap();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.value = Member.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key)
                ? MemberIdentifier.fromJSON(object.key)
                : undefined,
            value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined &&
            (obj.key = message.key
                ? MemberIdentifier.toJSON(message.key)
                : undefined);
        message.value !== undefined &&
            (obj.value = message.value ? Member.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMemberMap();
        message.key =
            object.key !== undefined && object.key !== null
                ? MemberIdentifier.fromPartial(object.key)
                : undefined;
        message.value =
            object.value !== undefined && object.value !== null
                ? Member.fromPartial(object.value)
                : undefined;
        return message;
    },
};
function createBaseAssociationState() {
    return {
        inboxId: "",
        members: [],
        recoveryIdentifier: "",
        seenSignatures: [],
        recoveryIdentifierKind: 0,
        relyingParty: undefined,
    };
}
export const AssociationState = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.inboxId !== "") {
            writer.uint32(10).string(message.inboxId);
        }
        for (const v of message.members) {
            MemberMap.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.recoveryIdentifier !== "") {
            writer.uint32(26).string(message.recoveryIdentifier);
        }
        for (const v of message.seenSignatures) {
            writer.uint32(34).bytes(v);
        }
        if (message.recoveryIdentifierKind !== 0) {
            writer.uint32(40).int32(message.recoveryIdentifierKind);
        }
        if (message.relyingParty !== undefined) {
            writer.uint32(50).string(message.relyingParty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssociationState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.inboxId = reader.string();
                    break;
                case 2:
                    message.members.push(MemberMap.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.recoveryIdentifier = reader.string();
                    break;
                case 4:
                    message.seenSignatures.push(reader.bytes());
                    break;
                case 5:
                    message.recoveryIdentifierKind = reader.int32();
                    break;
                case 6:
                    message.relyingParty = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : "",
            members: Array.isArray(object === null || object === void 0 ? void 0 : object.members)
                ? object.members.map((e) => MemberMap.fromJSON(e))
                : [],
            recoveryIdentifier: isSet(object.recoveryIdentifier)
                ? String(object.recoveryIdentifier)
                : "",
            seenSignatures: Array.isArray(object === null || object === void 0 ? void 0 : object.seenSignatures)
                ? object.seenSignatures.map((e) => bytesFromBase64(e))
                : [],
            recoveryIdentifierKind: isSet(object.recoveryIdentifierKind)
                ? identifierKindFromJSON(object.recoveryIdentifierKind)
                : 0,
            relyingParty: isSet(object.relyingParty)
                ? String(object.relyingParty)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        if (message.members) {
            obj.members = message.members.map((e) => e ? MemberMap.toJSON(e) : undefined);
        }
        else {
            obj.members = [];
        }
        message.recoveryIdentifier !== undefined &&
            (obj.recoveryIdentifier = message.recoveryIdentifier);
        if (message.seenSignatures) {
            obj.seenSignatures = message.seenSignatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.seenSignatures = [];
        }
        message.recoveryIdentifierKind !== undefined &&
            (obj.recoveryIdentifierKind = identifierKindToJSON(message.recoveryIdentifierKind));
        message.relyingParty !== undefined &&
            (obj.relyingParty = message.relyingParty);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseAssociationState();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        message.members =
            ((_b = object.members) === null || _b === void 0 ? void 0 : _b.map((e) => MemberMap.fromPartial(e))) || [];
        message.recoveryIdentifier = (_c = object.recoveryIdentifier) !== null && _c !== void 0 ? _c : "";
        message.seenSignatures = ((_d = object.seenSignatures) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.recoveryIdentifierKind = (_e = object.recoveryIdentifierKind) !== null && _e !== void 0 ? _e : 0;
        message.relyingParty = (_f = object.relyingParty) !== null && _f !== void 0 ? _f : undefined;
        return message;
    },
};
function createBaseAssociationStateDiff() {
    return { newMembers: [], removedMembers: [] };
}
export const AssociationStateDiff = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.newMembers) {
            MemberIdentifier.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.removedMembers) {
            MemberIdentifier.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssociationStateDiff();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.newMembers.push(MemberIdentifier.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.removedMembers.push(MemberIdentifier.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            newMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.newMembers)
                ? object.newMembers.map((e) => MemberIdentifier.fromJSON(e))
                : [],
            removedMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.removedMembers)
                ? object.removedMembers.map((e) => MemberIdentifier.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.newMembers) {
            obj.newMembers = message.newMembers.map((e) => e ? MemberIdentifier.toJSON(e) : undefined);
        }
        else {
            obj.newMembers = [];
        }
        if (message.removedMembers) {
            obj.removedMembers = message.removedMembers.map((e) => e ? MemberIdentifier.toJSON(e) : undefined);
        }
        else {
            obj.removedMembers = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAssociationStateDiff();
        message.newMembers =
            ((_a = object.newMembers) === null || _a === void 0 ? void 0 : _a.map((e) => MemberIdentifier.fromPartial(e))) || [];
        message.removedMembers =
            ((_b = object.removedMembers) === null || _b === void 0 ? void 0 : _b.map((e) => MemberIdentifier.fromPartial(e))) || [];
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=association.pb.js.map