import { ItemType } from "@opensea/seaport-js/lib/constants";
import { ethers } from "ethers";
import { Chain, Fee, OpenSeaAccount, OpenSeaCollection, OpenSeaPaymentToken, RarityStrategy, TokenStandard } from "../types";
export declare const collectionFromJSON: (collection: any) => OpenSeaCollection;
export declare const rarityFromJSON: (rarity: any) => RarityStrategy | null;
export declare const paymentTokenFromJSON: (token: any) => OpenSeaPaymentToken;
export declare const accountFromJSON: (account: any) => OpenSeaAccount;
export declare const feeFromJSON: (fee: any) => Fee;
/**
 * Estimate gas usage for a transaction.
 * @param provider The Provider
 * @param from Address sending transaction
 * @param to Destination contract address
 * @param data Data to send to contract
 * @param value Value in ETH to send with data
 */
export declare function estimateGas(provider: ethers.Provider, { from, to, data, value }: ethers.Transaction): Promise<bigint>;
/**
 * The longest time that an order is valid for is one month from the current date
 * @returns unix timestamp
 */
export declare const getMaxOrderExpirationTimestamp: () => number;
interface ErrorWithCode extends Error {
    code: string;
}
export declare const hasErrorCode: (error: unknown) => error is ErrorWithCode;
export declare const getAssetItemType: (tokenStandard: TokenStandard) => ItemType.ERC20 | ItemType.ERC721 | ItemType.ERC1155;
export declare const getChainId: (chain: Chain) => "1" | "137" | "80002" | "11155111" | "8217" | "1001" | "43114" | "43113" | "42161" | "42170" | "421614" | "238" | "168587773" | "8453" | "84532" | "10" | "11155420" | "7777777" | "999999999" | "1329" | "1328" | "8333" | "1993" | "80094" | "747" | "545" | "33139";
/** This should be the wrapped native asset for the chain. */
export declare const getWETHAddress: (chain: Chain) => "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2" | "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619" | "0x52eF3d68BaB452a294342DC3e5f464d7f610f72E" | "0x7b79995e5f793a07bc00c21412e50ecae098e7f9" | "0xfd844c2fca5e595004b17615f891620d1cb9bbb2" | "0x9330dd6713c8328a8d82b14e3f60a0f0b4cc7bfb" | "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7" | "0xd00ae08403B9bbb9124bB305C09058E32C39A48c" | "0x82af49447d8a07e3bd95bd0d56f35241523fbab1" | "0x722e8bdd2ce80a4422e880164f2079488e115365" | "0x980b62da83eff3d4576c647993b0c1d7faf17c73" | "0x4300000000000000000000000000000000000004" | "0x4200000000000000000000000000000000000023" | "0x4200000000000000000000000000000000000006" | "0x6969696969696969696969696969696969696969" | "0xe30fedd158a2e3b13e9badaeabafc5516e95e8c7" | "0x3921ea6cf927be80211bb57f19830700285b0ada" | "0xd3bf53dac106a0290b0483ecbc89d40fcc961f3e" | "0x23b1864b73c6E7Cd6D90bDFa3E62B159eBDdbAb3" | "0x48b62137edfa95a428d35c09e44256a739f6b557";
/**
 * Checks if the token address is the shared storefront address and if so replaces
 * that address with the lazy mint adapter address. Otherwise, returns the input token address
 * @param tokenAddress token address
 * @returns input token address or lazy mint adapter address
 */
export declare const getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress: (tokenAddress: string) => string;
/**
 * Sums up the basis points for fees.
 * @param fees The fees to sum up
 * @returns sum of basis points
 */
export declare const totalBasisPointsForFees: (fees: Fee[]) => bigint;
/**
 * Converts a fee to its basis points representation.
 * @param fee The fee to convert
 * @returns the basis points
 */
export declare const basisPointsForFee: (fee: Fee) => bigint;
/**
 * Checks whether the current chain is a test chain.
 * @param chain Chain to check.
 * @returns True if the chain is a test chain.
 */
export declare const isTestChain: (chain: Chain) => boolean;
/**
 * Returns if a protocol address is valid.
 * @param protocolAddress The protocol address
 */
export declare const isValidProtocol: (protocolAddress: string) => boolean;
/**
 * Throws an error if the protocol address is not valid.
 * @param protocolAddress The protocol address
 */
export declare const requireValidProtocol: (protocolAddress: string) => void;
/**
 * Decodes an encoded string of token IDs into an array of individual token IDs using bigint for precise calculations.
 *
 * The encoded token IDs can be in the following formats:
 * 1. Single numbers: '123' => ['123']
 * 2. Comma-separated numbers: '1,2,3,4' => ['1', '2', '3', '4']
 * 3. Ranges of numbers: '5:8' => ['5', '6', '7', '8']
 * 4. Combinations of single numbers and ranges: '1,3:5,8' => ['1', '3', '4', '5', '8']
 * 5. Wildcard '*' (matches all token IDs): '*' => ['*']
 *
 * @param encodedTokenIds - The encoded string of token IDs to be decoded.
 * @returns An array of individual token IDs after decoding the input.
 *
 * @throws {Error} If the input is not correctly formatted or if bigint operations fail.
 *
 * @example
 * const encoded = '1,3:5,8';
 * const decoded = decodeTokenIds(encoded); // Output: ['1', '3', '4', '5', '8']
 *
 * @example
 * const encodedWildcard = '*';
 * const decodedWildcard = decodeTokenIds(encodedWildcard); // Output: ['*']
 *
 * @example
 * const emptyEncoded = '';
 * const decodedEmpty = decodeTokenIds(emptyEncoded); // Output: []
 */
export declare const decodeTokenIds: (encodedTokenIds: string) => string[];
export {};
