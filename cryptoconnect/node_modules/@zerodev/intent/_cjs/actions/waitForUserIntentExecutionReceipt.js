"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaitForUserIntentExecutionReceiptTimeoutError = void 0;
exports.waitForUserIntentExecutionReceipt = waitForUserIntentExecutionReceipt;
const utils_1 = require("viem/utils");
const observe_js_1 = require("../utils/observe.js");
const poll_js_1 = require("../utils/poll.js");
const getUserIntentExecutionReceipt_js_1 = require("./getUserIntentExecutionReceipt.js");
class WaitForUserIntentExecutionReceiptTimeoutError extends Error {
    constructor({ uiHash }) {
        super(`Timed out waiting for user intent execution receipt: ${uiHash}`);
    }
}
exports.WaitForUserIntentExecutionReceiptTimeoutError = WaitForUserIntentExecutionReceiptTimeoutError;
function waitForUserIntentExecutionReceipt(client, parameters, version) {
    const { uiHash, pollingInterval = Math.min(client.pollingInterval, 1000), retryCount, timeout = 120_000, } = parameters;
    let count = 0;
    const observerId = (0, utils_1.stringify)([
        "waitForUserIntentExecutionReceipt",
        client.uid,
        uiHash,
    ]);
    return new Promise((resolve, reject) => {
        const unobserve = (0, observe_js_1.observe)(observerId, { resolve, reject }, (emit) => {
            const done = (fn) => {
                unpoll();
                fn();
                unobserve();
            };
            const unpoll = (0, poll_js_1.poll)(async () => {
                if (retryCount && count >= retryCount)
                    done(() => emit.reject(new WaitForUserIntentExecutionReceiptTimeoutError({ uiHash })));
                try {
                    const receipt = await (0, getUserIntentExecutionReceipt_js_1.getUserIntentExecutionReceipt)(client, {
                        uiHash,
                    }, version);
                    if (receipt)
                        done(() => emit.resolve(receipt));
                }
                catch (err) {
                    done(() => emit.reject(err));
                }
                count++;
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            if (timeout)
                setTimeout(() => done(() => emit.reject(new WaitForUserIntentExecutionReceiptTimeoutError({ uiHash }))), timeout);
            return unpoll;
        });
    });
}
//# sourceMappingURL=waitForUserIntentExecutionReceipt.js.map