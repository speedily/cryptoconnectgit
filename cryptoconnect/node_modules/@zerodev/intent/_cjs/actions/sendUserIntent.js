"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrderHash = void 0;
exports.sendUserIntent = sendUserIntent;
const multi_chain_ecdsa_validator_1 = require("@zerodev/multi-chain-ecdsa-validator");
const sdk_1 = require("@zerodev/sdk");
const constants_1 = require("@zerodev/sdk/constants");
const merkletreejs_1 = require("merkletreejs");
const viem_1 = require("viem");
const viem_2 = require("viem");
const utils_1 = require("viem/utils");
const constants_js_1 = require("../config/constants.js");
const prepareUserIntent_js_1 = require("./prepareUserIntent.js");
const getOrderHash = (order) => {
    if (order.orderDataType.toLowerCase() ===
        constants_js_1.V2_SAME_CHAIN_ORDER_DATA_TYPE.toLowerCase()) {
        return (0, viem_2.keccak256)((0, viem_2.encodeAbiParameters)((0, viem_2.parseAbiParameters)("address, uint256, uint32, uint32, bytes32, bytes32"), [
            order.user,
            order.nonce,
            order.openDeadline,
            order.fillDeadline,
            order.orderDataType,
            (0, viem_2.keccak256)(order.orderData),
        ]));
    }
    return (0, viem_2.keccak256)((0, viem_2.encodeAbiParameters)((0, viem_2.parseAbiParameters)("address, uint32, uint32, bytes32, bytes32"), [
        order.user,
        order.openDeadline,
        order.fillDeadline,
        order.orderDataType,
        (0, viem_2.keccak256)(order.orderData),
    ]));
};
exports.getOrderHash = getOrderHash;
const signOrders = async (orders, account) => {
    const signOrderMultichain = async (orders) => {
        const orderHashes = await Promise.all(orders.map(async (order) => {
            const orderHash = (0, viem_1.hashMessage)({ raw: (0, exports.getOrderHash)(order) });
            const wrappedMessageHash = await (0, sdk_1.eip712WrapHash)(orderHash, {
                name: "Kernel",
                chainId: BigInt(order.originChainId),
                version: account.kernelVersion,
                verifyingContract: account.address,
            }, true);
            return wrappedMessageHash;
        }));
        const merkleTree = new merkletreejs_1.MerkleTree(orderHashes, viem_2.keccak256, {
            sortPairs: true,
        });
        const merkleRoot = merkleTree.getHexRoot();
        const ecdsaSig = await account.kernelPluginManager.signMessage({
            message: {
                raw: merkleRoot,
            },
        });
        const encodeMerkleDataWithSig = (orderHash) => {
            const merkleProof = merkleTree.getHexProof(orderHash);
            const encodedMerkleProof = (0, viem_2.encodeAbiParameters)([{ name: "proof", type: "bytes32[]" }], [merkleProof]);
            return (0, viem_1.concatHex)([ecdsaSig, merkleRoot, encodedMerkleProof]);
        };
        const signatures = orderHashes.map((orderHash) => {
            const signature = (0, viem_1.concatHex)([
                constants_1.VALIDATOR_TYPE.SUDO,
                constants_1.MAGIC_VALUE_SIG_REPLAYABLE,
                encodeMerkleDataWithSig(orderHash),
            ]);
            const { signature: signature_ } = (0, viem_2.parseErc6492Signature)(signature);
            return signature_;
        });
        return signatures;
    };
    const identifier = account.kernelPluginManager.getIdentifier();
    const sudoValidator = (0, viem_1.slice)(identifier, 1);
    if ((0, viem_1.isAddressEqual)(sudoValidator, multi_chain_ecdsa_validator_1.MULTI_CHAIN_ECDSA_VALIDATOR_ADDRESS)) {
        return signOrderMultichain(orders);
    }
    return await Promise.all(orders.map(async (order) => {
        const orderHash = (0, exports.getOrderHash)(order);
        const signature = await account.signMessage({
            message: { raw: orderHash },
            useReplayableSignature: true,
        });
        const { signature: signature_ } = (0, viem_2.parseErc6492Signature)(signature);
        return signature_;
    }));
};
async function sendUserIntent(client, parameters, version) {
    const { account: account_ = client.account, intent: existingIntent, ...prepareParams } = parameters;
    if (!account_)
        throw new sdk_1.AccountNotFoundError();
    const account = (0, utils_1.parseAccount)(account_);
    const intent = existingIntent ??
        (await (0, prepareUserIntent_js_1.prepareUserIntent)(client, prepareParams, version));
    if (intent.orders.length === 0)
        throw new Error("No orders found");
    const signatures = await signOrders(intent.orders, account);
    const ordersWithSig = intent.orders.map((order, index) => ({
        order,
        signature: signatures[index],
    }));
    const uiHashes = await Promise.all(ordersWithSig.map(async ({ order, signature }) => {
        return await client.request({
            method: "rl_sendUserIntent",
            params: [
                {
                    order: order,
                    signature,
                    version,
                },
            ],
        });
    }));
    return {
        inputsUiHash: uiHashes.map((hash) => ({
            uiHash: hash.uiHash,
        })),
        outputUiHash: {
            uiHash: uiHashes[0].uiHash,
        },
    };
}
//# sourceMappingURL=sendUserIntent.js.map