"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecdsaGetMultiUserOpDummySignature = void 0;
const merkletreejs_1 = require("merkletreejs");
const viem_1 = require("viem");
const account_abstraction_1 = require("viem/account-abstraction");
const ecdsaGetMultiUserOpDummySignature = (userOperation, numOfUserOps, entryPoint, chainId) => {
    const userOpHash = (0, account_abstraction_1.getUserOperationHash)({
        userOperation,
        entryPointAddress: entryPoint.address,
        entryPointVersion: entryPoint.version,
        chainId
    });
    const dummyUserOpHash = `0x${"a".repeat(64)}`;
    const dummyLeaves = Array(numOfUserOps - 1).fill(dummyUserOpHash);
    const leaves = [userOpHash, ...dummyLeaves];
    const merkleTree = new merkletreejs_1.MerkleTree(leaves, viem_1.keccak256, {
        sortPairs: true
    });
    const merkleRoot = merkleTree.getHexRoot();
    const merkleProof = merkleTree.getHexProof(userOpHash);
    const dummyEcdsaSig = "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    const encodedMerkleProof = (0, viem_1.encodeAbiParameters)([
        { name: "dummyUserOpHash", type: "bytes32" },
        { name: "proof", type: "bytes32[]" }
    ], [userOpHash, merkleProof]);
    const finalDummySig = (0, viem_1.concatHex)([
        dummyEcdsaSig,
        merkleRoot,
        encodedMerkleProof
    ]);
    return finalDummySig;
};
exports.ecdsaGetMultiUserOpDummySignature = ecdsaGetMultiUserOpDummySignature;
//# sourceMappingURL=ecdsaGetMultiUserOpDummySignature.js.map