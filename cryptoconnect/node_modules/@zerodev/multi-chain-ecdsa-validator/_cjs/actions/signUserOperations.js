"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signUserOperations = void 0;
const sdk_1 = require("@zerodev/sdk");
const merkletreejs_1 = require("merkletreejs");
const account_abstraction_1 = require("viem/account-abstraction");
const utils_1 = require("viem/utils");
async function signUserOperations(client, args_) {
    const args = args_;
    const { account: account_ = client.account, userOperations } = args;
    if (!account_)
        throw new sdk_1.AccountNotFoundError();
    const account = (0, utils_1.parseAccount)(account_);
    const userOpHashes = userOperations.map((userOp) => {
        return (0, account_abstraction_1.getUserOperationHash)({
            userOperation: {
                ...userOp,
                signature: "0x"
            },
            entryPointAddress: account.entryPoint.address,
            entryPointVersion: account.entryPoint.version,
            chainId: userOp.chainId
        });
    });
    const merkleTree = new merkletreejs_1.default(userOpHashes, utils_1.keccak256, {
        sortPairs: true
    });
    const merkleRoot = merkleTree.getHexRoot();
    const ecdsaSig = await account.kernelPluginManager.signMessage({
        message: {
            raw: merkleRoot
        }
    });
    const encodeMerkleDataWithSig = (userOpHash) => {
        const merkleProof = merkleTree.getHexProof(userOpHash);
        const encodedMerkleProof = (0, utils_1.encodeAbiParameters)([{ name: "proof", type: "bytes32[]" }], [merkleProof]);
        return (0, utils_1.concatHex)([ecdsaSig, merkleRoot, encodedMerkleProof]);
    };
    const signedMultiUserOps = userOperations.map((userOp, index) => {
        return {
            ...userOp,
            signature: encodeMerkleDataWithSig(userOpHashes[index])
        };
    });
    return signedMultiUserOps;
}
exports.signUserOperations = signUserOperations;
//# sourceMappingURL=signUserOperations.js.map