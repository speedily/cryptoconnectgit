"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareAndSignUserOperations = void 0;
const sdk_1 = require("@zerodev/sdk");
const merkletreejs_1 = require("merkletreejs");
const viem_1 = require("viem");
const account_abstraction_1 = require("viem/account-abstraction");
const accounts_1 = require("viem/accounts");
const utils_1 = require("viem/utils");
async function prepareAndSignUserOperations(clients, args_) {
    if (clients.length < 2 && args_.length < 2) {
        throw new Error("Should send more than 1 user operation");
    }
    if (clients.length !== args_.length) {
        throw new Error("Number of clients and user operations do not match");
    }
    for (let i = 0; i < clients.length; i++) {
        const client = clients[i];
        const arg = args_[i];
        if (client.chain === undefined) {
            throw new Error("client.chain is undefined, please provide a chain");
        }
        if (client.chain.id !== arg.chainId) {
            throw new Error(`Chain ID mismatch at index ${i}: client.chainId (${client.chain.id}) !== args_.chainId (${arg.chainId})`);
        }
    }
    const args = args_;
    const accounts_ = args.map((arg, index) => arg.account ?? clients[index].account);
    if (!accounts_.every((account) => account !== undefined)) {
        throw new sdk_1.AccountNotFoundError();
    }
    const accounts = accounts_.map((account) => (0, accounts_1.parseAccount)(account));
    const _userOperations = args.map(({ chainId, ...userOp }) => userOp);
    const action = {
        selector: (0, viem_1.toFunctionSelector)((0, viem_1.getAbiItem)({ abi: sdk_1.KernelV3AccountAbi, name: "execute" })),
        address: viem_1.zeroAddress
    };
    const account = accounts[0];
    if (account.kernelPluginManager.regularValidator) {
        const isPluginEnabledPerChains = await Promise.all(accounts.map(async (account, index) => (await account.kernelPluginManager.isEnabled(account.address, action.selector)) ||
            (await (0, sdk_1.isPluginInitialized)(clients[index], account.address, account.kernelPluginManager.address))));
        const allEnabled = isPluginEnabledPerChains.every((enabled) => enabled);
        const noneEnabled = isPluginEnabledPerChains.every((enabled) => !enabled);
        if (!allEnabled && !noneEnabled) {
            throw new Error("Plugins must be either all enabled or all disabled across chains.");
        }
        if (noneEnabled) {
            const dummySignatures = await Promise.all(accounts.map(async (account, index) => {
                return account.kernelPluginManager.regularValidator?.getStubSignature(_userOperations[index]);
            }));
            for (const signature of dummySignatures) {
                if (signature === undefined) {
                    throw new Error("Dummy signatures are undefined");
                }
            }
            const pluginEnableTypedDatas = await Promise.all(accounts.map(async (account) => {
                return account.kernelPluginManager.getPluginsEnableTypedData(account.address);
            }));
            const leaves = pluginEnableTypedDatas.map((typedData) => {
                return (0, viem_1.hashTypedData)(typedData);
            });
            const merkleTree = new merkletreejs_1.MerkleTree(leaves, viem_1.keccak256, {
                sortPairs: true
            });
            const merkleRoot = merkleTree.getHexRoot();
            const ecdsaSig = await account.kernelPluginManager.sudoValidator?.signMessage({
                message: {
                    raw: merkleRoot
                }
            });
            if (!ecdsaSig) {
                throw new Error("No ecdsaSig, check if the sudo validator is multi-chain-ecdsa-validator");
            }
            const enableSigs = accounts.map((_, index) => {
                const merkleProof = merkleTree.getHexProof(leaves[index]);
                const encodedMerkleProof = (0, viem_1.encodeAbiParameters)([{ name: "proof", type: "bytes32[]" }], [merkleProof]);
                return (0, viem_1.concatHex)([ecdsaSig, merkleRoot, encodedMerkleProof]);
            });
            const encodedDummySignatures = await Promise.all(accounts.map(async (account, index) => {
                return (0, sdk_1.getEncodedPluginsData)({
                    enableSignature: enableSigs[index],
                    userOpSignature: dummySignatures[index],
                    action,
                    enableData: await account.kernelPluginManager.getEnableData(account.address)
                });
            }));
            for (const [index, userOperation] of _userOperations.entries()) {
                userOperation.signature = encodedDummySignatures[index];
            }
            const userOperations = await Promise.all(_userOperations.map(async (_userOperation, index) => {
                return await (0, utils_1.getAction)(clients[index], account_abstraction_1.prepareUserOperation, "prepareUserOperation")(_userOperation);
            }));
            const encodedSignatures = await Promise.all(userOperations.map(async (userOperation, index) => {
                return await (0, sdk_1.getEncodedPluginsData)({
                    enableSignature: enableSigs[index],
                    userOpSignature: await accounts[index].kernelPluginManager.signUserOperationWithActiveValidator(userOperation),
                    action,
                    enableData: await accounts[index].kernelPluginManager.getEnableData(account.address)
                });
            }));
            userOperations.forEach((userOperation, index) => {
                userOperation.signature = encodedSignatures[index];
            });
            return userOperations;
        }
        if (allEnabled) {
            const userOperations = await Promise.all(_userOperations.map(async (_userOperation, index) => {
                return await (0, utils_1.getAction)(clients[index], account_abstraction_1.prepareUserOperation, "prepareUserOperation")(_userOperation);
            }));
            const signatures = await Promise.all(userOperations.map((userOperation, index) => accounts[index].kernelPluginManager.signUserOperationWithActiveValidator(userOperation)));
            userOperations.forEach((userOperation, index) => {
                userOperation.signature = signatures[index];
            });
            return userOperations;
        }
    }
    const userOperations = await Promise.all(_userOperations.map(async (_userOperation, index) => {
        return await (0, utils_1.getAction)(clients[index], account_abstraction_1.prepareUserOperation, "prepareUserOperation")(_userOperation);
    }));
    const userOpHashes = userOperations.map((userOp, index) => {
        return (0, account_abstraction_1.getUserOperationHash)({
            userOperation: {
                ...userOp,
                signature: "0x"
            },
            entryPointAddress: account.entryPoint.address,
            entryPointVersion: account.entryPoint.version,
            chainId: args_[index].chainId
        });
    });
    const merkleTree = new merkletreejs_1.MerkleTree(userOpHashes, viem_1.keccak256, {
        sortPairs: true
    });
    const merkleRoot = merkleTree.getHexRoot();
    const ecdsaSig = await account.kernelPluginManager.signMessage({
        message: {
            raw: merkleRoot
        }
    });
    const encodeMerkleDataWithSig = (userOpHash) => {
        const merkleProof = merkleTree.getHexProof(userOpHash);
        const encodedMerkleProof = (0, viem_1.encodeAbiParameters)([{ name: "proof", type: "bytes32[]" }], [merkleProof]);
        return (0, viem_1.concatHex)([ecdsaSig, merkleRoot, encodedMerkleProof]);
    };
    const signedMultiUserOps = userOperations.map((userOp, index) => {
        return {
            ...userOp,
            signature: encodeMerkleDataWithSig(userOpHashes[index])
        };
    });
    return signedMultiUserOps;
}
exports.prepareAndSignUserOperations = prepareAndSignUserOperations;
//# sourceMappingURL=prepareAndSignUserOperations.js.map