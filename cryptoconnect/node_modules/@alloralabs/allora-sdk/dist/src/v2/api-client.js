"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlloraAPIClient = exports.SignatureFormat = exports.PriceInferenceTimeframe = exports.PriceInferenceToken = exports.ChainID = exports.ChainSlug = void 0;
var ChainSlug;
(function (ChainSlug) {
    ChainSlug["TESTNET"] = "testnet";
    ChainSlug["MAINNET"] = "mainnet";
})(ChainSlug || (exports.ChainSlug = ChainSlug = {}));
var ChainID;
(function (ChainID) {
    ChainID["TESTNET"] = "allora-testnet-1";
    ChainID["MAINNET"] = "allora-mainnet-1";
})(ChainID || (exports.ChainID = ChainID = {}));
var PriceInferenceToken;
(function (PriceInferenceToken) {
    PriceInferenceToken["BTC"] = "BTC";
    PriceInferenceToken["ETH"] = "ETH";
})(PriceInferenceToken || (exports.PriceInferenceToken = PriceInferenceToken = {}));
var PriceInferenceTimeframe;
(function (PriceInferenceTimeframe) {
    PriceInferenceTimeframe["FIVE_MIN"] = "5m";
    PriceInferenceTimeframe["EIGHT_HOURS"] = "8h";
})(PriceInferenceTimeframe || (exports.PriceInferenceTimeframe = PriceInferenceTimeframe = {}));
var SignatureFormat;
(function (SignatureFormat) {
    SignatureFormat["ETHEREUM_SEPOLIA"] = "ethereum-11155111";
})(SignatureFormat || (exports.SignatureFormat = SignatureFormat = {}));
class AlloraAPIClient {
    constructor(config) {
        this.chainID =
            config.chainSlug === ChainSlug.TESTNET
                ? ChainID.TESTNET
                : ChainID.MAINNET;
        this.apiKey = config.apiKey || "UP-8cbc632a67a84ac1b4078661";
        this.baseAPIUrl = config.baseAPIUrl || "https://api.upshot.xyz/v2";
    }
    /**
     * Fetches all available topics from the Allora API.
     * This method handles pagination automatically by following continuation tokens
     * until all topics have been retrieved.
     *
     * @returns {Promise<AlloraTopic[]>} A promise that resolves to an array of all available topics
     * @throws {Error} If the API request fails or returns an unsuccessful status
     */
    getAllTopics() {
        return __awaiter(this, void 0, void 0, function* () {
            const allTopics = [];
            let continuationToken = null;
            do {
                const response = yield this.fetchAPIResponse(`allora/${this.chainID}/topics`, continuationToken
                    ? {
                        continuation_token: continuationToken,
                    }
                    : {});
                allTopics.push(...response.data.topics);
                continuationToken = response.data.continuation_token;
            } while (continuationToken);
            return allTopics;
        });
    }
    /**
     * Fetches an inference for a specific topic from the Allora API.
     *
     * @param {number} topicID - The unique identifier of the topic to get inference for
     * @returns {Promise<AlloraInference>} A promise that resolves to the inference data
     * @throws {Error} If the API request fails or returns an unsuccessful status
     */
    getInferenceByTopicID(topicID_1) {
        return __awaiter(this, arguments, void 0, function* (topicID, signatureFormat = SignatureFormat.ETHEREUM_SEPOLIA) {
            var _a;
            const response = yield this.fetchAPIResponse(`allora/consumer/${signatureFormat}?allora_topic_id=${topicID}&inference_value_type=uint256`);
            if (!((_a = response.data) === null || _a === void 0 ? void 0 : _a.inference_data)) {
                throw new Error("Failed to fetch price inference");
            }
            return response.data;
        });
    }
    /**
     * Fetches a price inference for a specific asset and timeframe from the Allora API.
     *
     * @param {PriceInferenceToken} asset - The asset to get price inference for
     * @param {PriceInferenceTimeframe} timeframe - The timeframe to get price inference for
     * @returns {Promise<AlloraInference>} A promise that resolves to the inference data
     * @throws {Error} If the API request fails or returns an unsuccessful status
     */
    getPriceInference(asset_1, timeframe_1) {
        return __awaiter(this, arguments, void 0, function* (asset, timeframe, signatureFormat = SignatureFormat.ETHEREUM_SEPOLIA) {
            var _a;
            const response = yield this.fetchAPIResponse(`allora/consumer/price/${signatureFormat}/${asset}/${timeframe}`);
            if (!((_a = response.data) === null || _a === void 0 ? void 0 : _a.inference_data)) {
                throw new Error("Failed to fetch price inference");
            }
            return response.data;
        });
    }
    getRequestUrl(endpoint) {
        // Remove trailing slash from baseAPIUrl if it exists
        const apiUrl = this.baseAPIUrl.endsWith("/")
            ? this.baseAPIUrl.slice(0, -1)
            : this.baseAPIUrl;
        // Remove leading slash from endpoint if it exists
        endpoint = endpoint.startsWith("/") ? endpoint.slice(1) : endpoint;
        return `${apiUrl}/${endpoint}`;
    }
    fetchAPIResponse(endpoint_1) {
        return __awaiter(this, arguments, void 0, function* (endpoint, params = {}) {
            const queryString = new URLSearchParams(params).toString();
            const requestUrl = this.getRequestUrl(endpoint) + (queryString ? `?${queryString}` : "");
            const response = yield fetch(requestUrl, {
                method: "GET",
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json",
                    "x-api-key": this.apiKey,
                },
            });
            const responseBody = yield response.json();
            if (!response.ok) {
                throw new Error(`Failed to fetch from Allora API:  url=${requestUrl} status=${response.status} body=${JSON.stringify(responseBody, null, 4)}`);
            }
            return responseBody;
        });
    }
}
exports.AlloraAPIClient = AlloraAPIClient;
