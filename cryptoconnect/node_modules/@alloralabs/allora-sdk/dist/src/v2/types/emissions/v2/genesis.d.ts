import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { OffchainNode } from "./node";
import { Nonces, ReputerRequestNonces } from "./nonce";
import { Params } from "./params";
import { ReputerValueBundles, ValueBundle } from "./reputer";
import { Score, Scores } from "./score";
import { DelegateStakeRemovalInfo, DelegatorInfo, StakeRemovalInfo } from "./stake";
import { TimestampedActorNonce, Topic } from "./topic";
import { ListeningCoefficient } from "./types";
import { Forecast, Forecasts, Inference, Inferences, TimestampedValue } from "./worker";
export declare const protobufPackage = "emissions.v2";
/** GenesisState is the state that must be provided at genesis. */
export interface GenesisState {
    /** params defines all the parameters of the module. */
    params?: Params | undefined;
    /**
     * / TOPIC
     * the next topic id to be used, equal to the number of topics that have been
     * created
     */
    nextTopicId: string;
    /**
     * every topic that has been created indexed by their topicId starting from 1
     * (0 is reserved for the root network)
     */
    topics: TopicIdAndTopic[];
    activeTopics: string[];
    /**
     * every topic that has been churned and ready to be rewarded i.e. reputer
     * losses have been committed
     */
    rewardableTopics: string[];
    /** for a topic, what is every worker node that has registered to it? */
    topicWorkers: TopicAndActorId[];
    /** for a topic, what is every reputer node that has registered to it? */
    topicReputers: TopicAndActorId[];
    /** map of (topic) -> nonce/block height */
    topicRewardNonce: TopicIdAndBlockHeight[];
    /**
     * / SCORES
     * map of (topic, block_height, worker) -> score
     */
    infererScoresByBlock: TopicIdBlockHeightScores[];
    /** map of (topic, block_height, worker) -> score */
    forecasterScoresByBlock: TopicIdBlockHeightScores[];
    /** map of (topic, block_height, reputer) -> score */
    reputerScoresByBlock: TopicIdBlockHeightScores[];
    /** map of (topic, block_height, worker) -> score */
    latestInfererScoresByWorker: TopicIdActorIdScore[];
    /** map of (topic, block_height, worker) -> score */
    latestForecasterScoresByWorker: TopicIdActorIdScore[];
    /** map of (topic, block_height, reputer) -> score */
    latestReputerScoresByReputer: TopicIdActorIdScore[];
    /** map of (topic, reputer) -> listening coefficient */
    reputerListeningCoefficient: TopicIdActorIdListeningCoefficient[];
    /** map of (topic, reputer) -> previous reward (used for EMA) */
    previousReputerRewardFraction: TopicIdActorIdDec[];
    /** map of (topic, worker) -> previous reward for inference (used for EMA) */
    previousInferenceRewardFraction: TopicIdActorIdDec[];
    /** map of (topic, worker) -> previous reward for forecast (used for EMA) */
    previousForecastRewardFraction: TopicIdActorIdDec[];
    /** map of (topic, forecaster) -> ratio of forecaster score */
    previousForecasterScoreRatio: TopicIdActorIdDec[];
    /** total sum stake of all stakers on the network */
    totalStake: string;
    /** for every topic, how much total stake does that topic have accumulated? */
    topicStake: TopicIdAndInt[];
    /**
     * stake reputer placed in topic + delegate stake placed in them,
     * signalling their total authority on the topic
     * (topic Id, reputer) -> stake from reputer on self +
     * stakeFromDelegatorsUponReputer
     */
    stakeReputerAuthority: TopicIdActorIdInt[];
    /**
     * map of (topic id, delegator) -> total amount of stake in that topic placed
     * by that delegator
     */
    stakeSumFromDelegator: TopicIdActorIdInt[];
    /**
     * map of (topic id, delegator, reputer) -> amount of stake that has been
     * placed by that delegator on that target
     */
    delegatedStakes: TopicIdDelegatorReputerDelegatorInfo[];
    /**
     * map of (topic id, reputer) -> total amount of stake that has been placed on
     * that reputer by delegators
     */
    stakeFromDelegatorsUponReputer: TopicIdActorIdInt[];
    /** map of (topicId, reputer) -> share of delegate reward */
    delegateRewardPerShare: TopicIdActorIdDec[];
    /**
     * stake removals are double indexed to avoid O(n) lookups when removing stake
     * map of (blockHeight, topic, reputer) -> removal information for that
     * reputer
     */
    stakeRemovalsByBlock: BlockHeightTopicIdReputerStakeRemovalInfo[];
    /**
     * key set of (reputer, topic, blockHeight) to existence of a removal in the
     * forwards map
     */
    stakeRemovalsByActor: ActorIdTopicIdBlockHeight[];
    /**
     * delegate stake removals are double indexed to avoid O(n) lookups when
     * removing stake map of (blockHeight, topic, delegator, reputer staked upon)
     * -> (list of reputers delegated upon and info) to have stake removed at that
     * block
     */
    delegateStakeRemovalsByBlock: BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo[];
    /**
     * key set of (delegator, reputer, topicId, blockHeight) to existence of a
     * removal in the forwards map
     */
    delegateStakeRemovalsByActor: DelegatorReputerTopicIdBlockHeight[];
    /**
     * / MISC GLOBAL STATE
     * map of (topic, worker) -> inference
     */
    inferences: TopicIdActorIdInference[];
    /** map of (topic, worker) -> forecast[] */
    forecasts: TopicIdActorIdForecast[];
    /** map of worker id to node data about that worker */
    workers: LibP2pKeyAndOffchainNode[];
    /** map of reputer id to node data about that reputer */
    reputers: LibP2pKeyAndOffchainNode[];
    /** fee revenue collected by a topic over the course of the last reward cadence */
    topicFeeRevenue: TopicIdAndInt[];
    /** store previous weights for exponential moving average in rewards calc */
    previousTopicWeight: TopicIdAndDec[];
    /** map of (topic, block_height) -> Inference */
    allInferences: TopicIdBlockHeightInferences[];
    /** map of (topic, block_height) -> Forecast */
    allForecasts: TopicIdBlockHeightForecasts[];
    /**
     * map of (topic, block_height) -> ReputerValueBundles (1 per reputer active
     * at that time)
     */
    allLossBundles: TopicIdBlockHeightReputerValueBundles[];
    /**
     * map of (topic, block_height) -> ValueBundle (1 network wide bundle per
     * timestep)
     */
    networkLossBundles: TopicIdBlockHeightValueBundles[];
    /**
     * Percentage of all rewards, paid out to staked reputers, during the previous
     * reward cadence. Used by mint module
     */
    previousPercentageRewardToStakedReputers: string;
    /**
     * / NONCES
     * map of (topic) -> unfulfilled nonces
     */
    unfulfilledWorkerNonces: TopicIdAndNonces[];
    /** map of (topic) -> unfulfilled nonces */
    unfulfilledReputerNonces: TopicIdAndReputerRequestNonces[];
    /**
     * / REGRETS
     * map of (topic, worker) -> regret of worker from comparing loss of worker
     * relative to loss of other inferers
     */
    latestInfererNetworkRegrets: TopicIdActorIdTimeStampedValue[];
    /**
     * map of (topic, worker) -> regret of worker from comparing loss of worker
     * relative to loss of other forecasters
     */
    latestForecasterNetworkRegrets: TopicIdActorIdTimeStampedValue[];
    /**
     * map of (topic, forecaster, inferer) -> R^+_{ij_kk} regret of forecaster
     * loss from comparing one-in loss with all network inferer (3rd index)
     * regrets L_ij made under the regime of the one-in forecaster (2nd index)
     */
    latestOneInForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    /**
     * the forecaster (2nd index) regrets made under the regime of the same
     * forecaster as a one-in forecaster
     */
    latestNaiveInfererNetworkRegrets: TopicIdActorIdTimeStampedValue[];
    latestOneOutInfererInfererNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    latestOneOutInfererForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    latestOneOutForecasterInfererNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    latestOneOutForecasterForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    /** / WHITELISTS */
    coreTeamAddresses: string[];
    /** / RECORD COMMITS */
    topicLastWorkerCommit: TopicIdTimestampedActorNonce[];
    topicLastReputerCommit: TopicIdTimestampedActorNonce[];
}
export interface TopicIdAndTopic {
    TopicId: string;
    Topic?: Topic | undefined;
}
export interface TopicAndActorId {
    TopicId: string;
    ActorId: string;
}
export interface TopicIdAndBlockHeight {
    TopicId: string;
    BlockHeight: string;
}
export interface TopicIdBlockHeightScores {
    TopicId: string;
    BlockHeight: string;
    Scores?: Scores | undefined;
}
export interface TopicIdActorIdScore {
    TopicId: string;
    ActorId: string;
    Score?: Score | undefined;
}
export interface TopicIdActorIdListeningCoefficient {
    TopicId: string;
    ActorId: string;
    ListeningCoefficient?: ListeningCoefficient | undefined;
}
export interface TopicIdActorIdDec {
    TopicId: string;
    ActorId: string;
    Dec: string;
}
export interface TopicIdAndInt {
    TopicId: string;
    Int: string;
}
export interface TopicIdActorIdInt {
    TopicId: string;
    ActorId: string;
    Int: string;
}
export interface TopicIdDelegatorReputerDelegatorInfo {
    TopicId: string;
    Delegator: string;
    Reputer: string;
    DelegatorInfo?: DelegatorInfo | undefined;
}
export interface BlockHeightTopicIdReputerStakeRemovalInfo {
    BlockHeight: string;
    TopicId: string;
    Reputer: string;
    StakeRemovalInfo?: StakeRemovalInfo | undefined;
}
export interface ActorIdTopicIdBlockHeight {
    ActorId: string;
    TopicId: string;
    BlockHeight: string;
}
export interface BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
    BlockHeight: string;
    TopicId: string;
    Delegator: string;
    Reputer: string;
    DelegateStakeRemovalInfo?: DelegateStakeRemovalInfo | undefined;
}
export interface DelegatorReputerTopicIdBlockHeight {
    Delegator: string;
    Reputer: string;
    TopicId: string;
    BlockHeight: string;
}
export interface TopicIdActorIdInference {
    TopicId: string;
    ActorId: string;
    Inference?: Inference | undefined;
}
export interface TopicIdActorIdForecast {
    TopicId: string;
    ActorId: string;
    Forecast?: Forecast | undefined;
}
export interface LibP2pKeyAndOffchainNode {
    LibP2pKey: string;
    OffchainNode?: OffchainNode | undefined;
}
export interface TopicIdAndDec {
    TopicId: string;
    Dec: string;
}
export interface TopicIdBlockHeightInferences {
    TopicId: string;
    BlockHeight: string;
    Inferences?: Inferences | undefined;
}
export interface TopicIdBlockHeightForecasts {
    TopicId: string;
    BlockHeight: string;
    Forecasts?: Forecasts | undefined;
}
export interface TopicIdBlockHeightReputerValueBundles {
    TopicId: string;
    BlockHeight: string;
    ReputerValueBundles?: ReputerValueBundles | undefined;
}
export interface TopicIdBlockHeightValueBundles {
    TopicId: string;
    BlockHeight: string;
    ValueBundle?: ValueBundle | undefined;
}
export interface TopicIdAndNonces {
    TopicId: string;
    Nonces?: Nonces | undefined;
}
export interface TopicIdAndReputerRequestNonces {
    TopicId: string;
    ReputerRequestNonces?: ReputerRequestNonces | undefined;
}
export interface TopicIdActorIdTimeStampedValue {
    TopicId: string;
    ActorId: string;
    TimestampedValue?: TimestampedValue | undefined;
}
export interface TopicIdActorIdActorIdTimeStampedValue {
    TopicId: string;
    ActorId1: string;
    ActorId2: string;
    TimestampedValue?: TimestampedValue | undefined;
}
export interface TopicIdTimestampedActorNonce {
    TopicId: string;
    TimestampedActorNonce?: TimestampedActorNonce | undefined;
}
export declare const GenesisState: MessageFns<GenesisState>;
export declare const TopicIdAndTopic: MessageFns<TopicIdAndTopic>;
export declare const TopicAndActorId: MessageFns<TopicAndActorId>;
export declare const TopicIdAndBlockHeight: MessageFns<TopicIdAndBlockHeight>;
export declare const TopicIdBlockHeightScores: MessageFns<TopicIdBlockHeightScores>;
export declare const TopicIdActorIdScore: MessageFns<TopicIdActorIdScore>;
export declare const TopicIdActorIdListeningCoefficient: MessageFns<TopicIdActorIdListeningCoefficient>;
export declare const TopicIdActorIdDec: MessageFns<TopicIdActorIdDec>;
export declare const TopicIdAndInt: MessageFns<TopicIdAndInt>;
export declare const TopicIdActorIdInt: MessageFns<TopicIdActorIdInt>;
export declare const TopicIdDelegatorReputerDelegatorInfo: MessageFns<TopicIdDelegatorReputerDelegatorInfo>;
export declare const BlockHeightTopicIdReputerStakeRemovalInfo: MessageFns<BlockHeightTopicIdReputerStakeRemovalInfo>;
export declare const ActorIdTopicIdBlockHeight: MessageFns<ActorIdTopicIdBlockHeight>;
export declare const BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo: MessageFns<BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo>;
export declare const DelegatorReputerTopicIdBlockHeight: MessageFns<DelegatorReputerTopicIdBlockHeight>;
export declare const TopicIdActorIdInference: MessageFns<TopicIdActorIdInference>;
export declare const TopicIdActorIdForecast: MessageFns<TopicIdActorIdForecast>;
export declare const LibP2pKeyAndOffchainNode: MessageFns<LibP2pKeyAndOffchainNode>;
export declare const TopicIdAndDec: MessageFns<TopicIdAndDec>;
export declare const TopicIdBlockHeightInferences: MessageFns<TopicIdBlockHeightInferences>;
export declare const TopicIdBlockHeightForecasts: MessageFns<TopicIdBlockHeightForecasts>;
export declare const TopicIdBlockHeightReputerValueBundles: MessageFns<TopicIdBlockHeightReputerValueBundles>;
export declare const TopicIdBlockHeightValueBundles: MessageFns<TopicIdBlockHeightValueBundles>;
export declare const TopicIdAndNonces: MessageFns<TopicIdAndNonces>;
export declare const TopicIdAndReputerRequestNonces: MessageFns<TopicIdAndReputerRequestNonces>;
export declare const TopicIdActorIdTimeStampedValue: MessageFns<TopicIdActorIdTimeStampedValue>;
export declare const TopicIdActorIdActorIdTimeStampedValue: MessageFns<TopicIdActorIdActorIdTimeStampedValue>;
export declare const TopicIdTimestampedActorNonce: MessageFns<TopicIdTimestampedActorNonce>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=genesis.d.ts.map