import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export declare const protobufPackage = "emissions.v3";
/** Params defines the parameters of the module. */
export interface Params {
    /** version of the protocol should be in lockstep with */
    version: string;
    /** github release tag version */
    maxSerializedMsgLength: string;
    /** total unmet demand for a topic < this => don't run inference */
    minTopicWeight: string;
    /** solicatation or weight-adjustment */
    requiredMinimumStake: string;
    /** how long to wait (blocks) before allowed to remove stake */
    removeStakeDelayWindow: string;
    /** fastest allowable topic epoch and cadence of a */
    minEpochLength: string;
    /** repeating inference request */
    betaEntropy: string;
    /** speed of gradient descent */
    learningRate: string;
    /** gradient descent stops when gradient falls below this */
    maxGradientThreshold: string;
    /** minimum fraction of stake to listen to when setting consensus listening */
    minStakeFraction: string;
    /** coefficients */
    maxUnfulfilledWorkerRequests: string;
    /** max num reputer request nonces to keep track of per topic */
    maxUnfulfilledReputerRequests: string;
    /** The exponent Î¼ represents the importance of stake in the reward of a */
    topicRewardStakeImportance: string;
    /** topic and has a fiducial value of 0.5 */
    topicRewardFeeRevenueImportance: string;
    /** a topic and has a fiducial value of 0.5 */
    topicRewardAlpha: string;
    /** a monthly timescale, 0.5 for weekly updates */
    taskRewardAlpha: string;
    /** to calculate ~U_ij, ~V_ik, ~W_im */
    validatorsVsAlloraPercentReward: string;
    /** to allora reputers workers etc */
    maxSamplesToScaleScores: string;
    /** max number of top inferers by score to reward */
    maxTopInferersToReward: string;
    /** max number of top forecasters by score to reward */
    maxTopForecastersToReward: string;
    /** max number of top reputers by score to reward */
    maxTopReputersToReward: string;
    /** topic registration fee */
    createTopicFee: string;
    /** max number of gradient descent iterations */
    gradientDescentMaxIters: string;
    /** registration fee for reputer or worker */
    registrationFee: string;
    /** default limit for pagination */
    defaultPageLimit: string;
    /** max limit for pagination */
    maxPageLimit: string;
    /**
     * min number of epochs to keep network losses, reputer losses, inferences,
     * forecasts
     */
    minEpochLengthRecordLimit: string;
    /** block emission rate in number of blocks expected per month */
    blocksPerMonth: string;
    pRewardInference: string;
    pRewardForecast: string;
    pRewardReputer: string;
    cRewardInference: string;
    cRewardForecast: string;
    cNorm: string;
    /** a small tolerance quantity used to cap reputer scores at infinitesimally */
    epsilonReputer: string;
    /** close proximities */
    halfMaxProcessStakeRemovalsEndBlock: string;
    /**
     * Applied twice once for stakeRemovals and once for
     * DelegateStakeRemovals, so actual max is this number times two
     */
    epsilonSafeDiv: string;
    /** / a small tolerance quantity used to cap division by zero */
    dataSendingFee: string;
    /** payload sending fee for reputer or worker */
    maxElementsPerForecast: string;
    /** max number of active topics per block */
    maxActiveTopicsPerBlock: string;
}
export declare const Params: MessageFns<Params>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=params.d.ts.map