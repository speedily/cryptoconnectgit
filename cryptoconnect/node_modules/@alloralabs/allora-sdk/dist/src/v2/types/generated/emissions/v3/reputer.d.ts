import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ReputerRequestNonce } from "./nonce";
export declare const protobufPackage = "emissions.v3";
export interface WorkerAttributedValue {
    /** worker who created the value */
    worker: string;
    value: string;
}
export interface WithheldWorkerAttributedValue {
    worker: string;
    value: string;
}
export interface OneOutInfererForecasterValues {
    forecaster: string;
    oneOutInfererValues: WithheldWorkerAttributedValue[];
}
/**
 * These losses and inferences are calculated per reputer or by the network
 * The `m`s in the comments below exist for when they're made by reputers,
 * but they may be absent implying that they were made by the network
 */
export interface ValueBundle {
    topicId: string;
    reputerRequestNonce?: ReputerRequestNonce | undefined;
    reputer: string;
    extraData: Uint8Array;
    /** R_im || log10 L_im || I_i */
    combinedValue: string;
    /** R_ijm || log10 L_ijm || I_ij */
    infererValues: WorkerAttributedValue[];
    /** R_ikm || log10 L_ikm || I_ik */
    forecasterValues: WorkerAttributedValue[];
    /** R^-_im  || log10 L^-_im || I^-_i */
    naiveValue: string;
    /**
     * Note: forecast-implied inferences are recomputed for each left-out
     * inference
     */
    oneOutInfererValues: WithheldWorkerAttributedValue[];
    /** R^-_ilm || log10 L^-_ilm || I^-_il where l = any k */
    oneOutForecasterValues: WithheldWorkerAttributedValue[];
    /**
     * R^+_ikm || log10 L^+_ikm || I^+_ik
     * aka one_in_forecaster_values because equivalent to using only one
     * forecast-implied inference
     */
    oneInForecasterValues: WorkerAttributedValue[];
    /**
     * R^-_ilm || log10 L^-_ilm || I^-_il where l = any j
     * log10 L^-_j'ikm || I^-_j'ik
     */
    oneOutInfererForecasterValues: OneOutInfererForecasterValues[];
}
/**
 * For when the bundle is computed on a per-reputer basis (ie.. if there is an
 * index `m` in the above)
 */
export interface ReputerValueBundle {
    valueBundle?: ValueBundle | undefined;
    signature: Uint8Array;
    pubkey: string;
}
export interface ReputerValueBundles {
    reputerValueBundles: ReputerValueBundle[];
}
export declare const WorkerAttributedValue: MessageFns<WorkerAttributedValue>;
export declare const WithheldWorkerAttributedValue: MessageFns<WithheldWorkerAttributedValue>;
export declare const OneOutInfererForecasterValues: MessageFns<OneOutInfererForecasterValues>;
export declare const ValueBundle: MessageFns<ValueBundle>;
export declare const ReputerValueBundle: MessageFns<ReputerValueBundle>;
export declare const ReputerValueBundles: MessageFns<ReputerValueBundles>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=reputer.d.ts.map