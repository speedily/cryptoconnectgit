import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { OffchainNode } from "../v3/node";
import { Nonces, ReputerRequestNonces } from "../v3/nonce";
import { ReputerValueBundle, ReputerValueBundles, ValueBundle } from "../v3/reputer";
import { Score, Scores } from "../v3/score";
import { DelegateStakeRemovalInfo, DelegatorInfo, StakeRemovalInfo } from "../v3/stake";
import { TimestampedActorNonce, Topic, TopicIds, TopicIdWeightPair } from "../v3/topic";
import { ListeningCoefficient } from "../v3/types";
import { Forecast, Forecasts, Inference, Inferences, TimestampedValue } from "../v3/worker";
import { Params } from "./params";
export declare const protobufPackage = "emissions.v5";
/** GenesisState is the state that must be provided at genesis. */
export interface GenesisState {
    /** params defines all the parameters of the module. */
    params?: Params | undefined;
    /**
     * / TOPIC
     * the next topic id to be used, equal to the number of topics that have been
     * created
     */
    nextTopicId: string;
    /**
     * every topic that has been created indexed by their topicId starting from 1
     * (0 is reserved for the root network)
     */
    topics: TopicIdAndTopic[];
    activeTopics: string[];
    /**
     * every topic that has been churned and ready to be rewarded i.e. reputer
     * losses have been committed
     */
    rewardableTopics: string[];
    /** for a topic, what is every worker node that has registered to it? */
    topicWorkers: TopicAndActorId[];
    /** for a topic, what is every reputer node that has registered to it? */
    topicReputers: TopicAndActorId[];
    /** map of (topic) -> nonce/block height */
    topicRewardNonce: TopicIdAndBlockHeight[];
    /**
     * / SCORES
     * map of (topic, block_height, worker) -> score
     */
    infererScoresByBlock: TopicIdBlockHeightScores[];
    /** map of (topic, block_height, worker) -> score */
    forecasterScoresByBlock: TopicIdBlockHeightScores[];
    /** map of (topic, block_height, reputer) -> score */
    reputerScoresByBlock: TopicIdBlockHeightScores[];
    /** map of (topic, block_height, worker) -> score */
    infererScoreEmas: TopicIdActorIdScore[];
    /** map of (topic, block_height, worker) -> score */
    forecasterScoreEmas: TopicIdActorIdScore[];
    /** map of (topic, block_height, reputer) -> score */
    reputerScoreEmas: TopicIdActorIdScore[];
    /** map of (topic, reputer) -> listening coefficient */
    reputerListeningCoefficient: TopicIdActorIdListeningCoefficient[];
    /** map of (topic, reputer) -> previous reward (used for EMA) */
    previousReputerRewardFraction: TopicIdActorIdDec[];
    /** map of (topic, worker) -> previous reward for inference (used for EMA) */
    previousInferenceRewardFraction: TopicIdActorIdDec[];
    /** map of (topic, worker) -> previous reward for forecast (used for EMA) */
    previousForecastRewardFraction: TopicIdActorIdDec[];
    /** map of (topic, forecaster) -> ratio of forecaster score */
    previousForecasterScoreRatio: TopicIdAndDec[];
    /** total sum stake of all stakers on the network */
    totalStake: string;
    /** for every topic, how much total stake does that topic have accumulated? */
    topicStake: TopicIdAndInt[];
    /**
     * stake reputer placed in topic + delegate stake placed in them,
     * signalling their total authority on the topic
     * (topic Id, reputer) -> stake from reputer on self +
     * stakeFromDelegatorsUponReputer
     */
    stakeReputerAuthority: TopicIdActorIdInt[];
    /**
     * map of (topic id, delegator) -> total amount of stake in that topic placed
     * by that delegator
     */
    stakeSumFromDelegator: TopicIdActorIdInt[];
    /**
     * map of (topic id, delegator, reputer) -> amount of stake that has been
     * placed by that delegator on that target
     */
    delegatedStakes: TopicIdDelegatorReputerDelegatorInfo[];
    /**
     * map of (topic id, reputer) -> total amount of stake that has been placed on
     * that reputer by delegators
     */
    stakeFromDelegatorsUponReputer: TopicIdActorIdInt[];
    /** map of (topicId, reputer) -> share of delegate reward */
    delegateRewardPerShare: TopicIdActorIdDec[];
    /**
     * stake removals are double indexed to avoid O(n) lookups when removing stake
     * map of (blockHeight, topic, reputer) -> removal information for that
     * reputer
     */
    stakeRemovalsByBlock: BlockHeightTopicIdReputerStakeRemovalInfo[];
    /**
     * key set of (reputer, topic, blockHeight) to existence of a removal in the
     * forwards map
     */
    stakeRemovalsByActor: ActorIdTopicIdBlockHeight[];
    /**
     * delegate stake removals are double indexed to avoid O(n) lookups when
     * removing stake map of (blockHeight, topic, delegator, reputer staked upon)
     * -> (list of reputers delegated upon and info) to have stake removed at that
     * block
     */
    delegateStakeRemovalsByBlock: BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo[];
    /**
     * key set of (delegator, reputer, topicId, blockHeight) to existence of a
     * removal in the forwards map
     */
    delegateStakeRemovalsByActor: DelegatorReputerTopicIdBlockHeight[];
    /**
     * / MISC GLOBAL STATE
     * map of (topic, worker) -> inference
     */
    inferences: TopicIdActorIdInference[];
    /** map of (topic, worker) -> forecast[] */
    forecasts: TopicIdActorIdForecast[];
    /** map of worker id to node data about that worker */
    workers: LibP2pKeyAndOffchainNode[];
    /** map of reputer id to node data about that reputer */
    reputers: LibP2pKeyAndOffchainNode[];
    /** fee revenue collected by a topic over the course of the last reward cadence */
    topicFeeRevenue: TopicIdAndInt[];
    /** store previous weights for exponential moving average in rewards calc */
    previousTopicWeight: TopicIdAndDec[];
    /** map of (topic, block_height) -> Inference */
    allInferences: TopicIdBlockHeightInferences[];
    /** map of (topic, block_height) -> Forecast */
    allForecasts: TopicIdBlockHeightForecasts[];
    /**
     * map of (topic, block_height) -> ReputerValueBundles (1 per reputer active
     * at that time)
     */
    allLossBundles: TopicIdBlockHeightReputerValueBundles[];
    /**
     * map of (topic, block_height) -> ValueBundle (1 network wide bundle per
     * timestep)
     */
    networkLossBundles: TopicIdBlockHeightValueBundles[];
    /**
     * Percentage of all rewards, paid out to staked reputers, during the previous
     * reward cadence. Used by mint module
     */
    previousPercentageRewardToStakedReputers: string;
    /** map of open worker nonce windows for topics on particular block heights */
    openWorkerWindows: BlockHeightAndTopicIds[];
    /** map of (topic) -> unfulfilled nonces */
    unfulfilledWorkerNonces: TopicIdAndNonces[];
    /** map of (topic) -> unfulfilled nonces */
    unfulfilledReputerNonces: TopicIdAndReputerRequestNonces[];
    /** map of (topic) -> last dripped block */
    lastDripBlock: TopicIdAndBlockHeight[];
    /**
     * / REGRETS
     * map of (topic, worker) -> regret of worker from comparing loss of worker
     * relative to loss of other inferers
     */
    latestInfererNetworkRegrets: TopicIdActorIdTimeStampedValue[];
    /**
     * map of (topic, worker) -> regret of worker from comparing loss of worker
     * relative to loss of other forecasters
     */
    latestForecasterNetworkRegrets: TopicIdActorIdTimeStampedValue[];
    /**
     * map of (topic, forecaster, inferer) -> R^+_{ij_kk} regret of forecaster
     * loss from comparing one-in loss with all network inferer (3rd index)
     * regrets L_ij made under the regime of the one-in forecaster (2nd index)
     */
    latestOneInForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    /**
     * the forecaster (2nd index) regrets made under the regime of the same
     * forecaster as a one-in forecaster
     */
    latestNaiveInfererNetworkRegrets: TopicIdActorIdTimeStampedValue[];
    latestOneOutInfererInfererNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    latestOneOutInfererForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    latestOneOutForecasterInfererNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    latestOneOutForecasterForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
    /** / WHITELISTS */
    coreTeamAddresses: string[];
    /** / RECORD COMMITS */
    topicLastWorkerCommit: TopicIdTimestampedActorNonce[];
    topicLastReputerCommit: TopicIdTimestampedActorNonce[];
    /** ACTIVE TOPIC */
    topicToNextPossibleChurningBlock: TopicIdAndBlockHeight[];
    blockToActiveTopics: BlockHeightTopicIds[];
    blockToLowestActiveTopicWeight: BlockHeightTopicIdWeightPair[];
    /** EMA */
    previousTopicQuantileInfererScoreEma: TopicIdAndDec[];
    previousTopicQuantileForecasterScoreEma: TopicIdAndDec[];
    previousTopicQuantileReputerScoreEma: TopicIdAndDec[];
    /** INCLUSIONS */
    countInfererInclusionsInTopicActiveSet: TopicIdActorIdUint64[];
    countForecasterInclusionsInTopicActiveSet: TopicIdActorIdUint64[];
    /** active inferers for each topic */
    activeInferers: TopicAndActorId[];
    /** active forecasters for each topic */
    activeForecasters: TopicAndActorId[];
    /** lowest inferer score EMA for each topic */
    lowestInfererScoreEma: TopicIdActorIdScore[];
    /** lowest forecaster score EMA for each topic */
    lowestForecasterScoreEma: TopicIdActorIdScore[];
    /** active reputers for each topic */
    activeReputers: TopicAndActorId[];
    /** lowest reputer score EMA for each topic */
    lowestReputerScoreEma: TopicIdActorIdScore[];
    /** map of (topic, reputer) -> reputer loss */
    lossBundles: TopicIdReputerReputerValueBundle[];
    /** total sum of topic weights */
    totalSumPreviousTopicWeights: string;
    /** reward emission on current block */
    rewardCurrentBlockEmission: string;
}
export interface TopicIdAndTopic {
    topicId: string;
    topic?: Topic | undefined;
}
export interface TopicAndActorId {
    topicId: string;
    actorId: string;
}
export interface TopicIdAndBlockHeight {
    topicId: string;
    blockHeight: string;
}
export interface BlockHeightAndTopicIds {
    blockHeight: string;
    topicIds: string[];
}
export interface TopicIdBlockHeightScores {
    topicId: string;
    blockHeight: string;
    scores?: Scores | undefined;
}
export interface TopicIdActorIdScore {
    topicId: string;
    actorId: string;
    score?: Score | undefined;
}
export interface TopicIdActorIdUint64 {
    topicId: string;
    actorId: string;
    uint64: string;
}
export interface TopicIdActorIdListeningCoefficient {
    topicId: string;
    actorId: string;
    listeningCoefficient?: ListeningCoefficient | undefined;
}
export interface TopicIdActorIdDec {
    topicId: string;
    actorId: string;
    dec: string;
}
export interface TopicIdAndInt {
    topicId: string;
    int: string;
}
export interface TopicIdActorIdInt {
    topicId: string;
    actorId: string;
    int: string;
}
export interface TopicIdDelegatorReputerDelegatorInfo {
    topicId: string;
    delegator: string;
    reputer: string;
    delegatorInfo?: DelegatorInfo | undefined;
}
export interface BlockHeightTopicIdReputerStakeRemovalInfo {
    blockHeight: string;
    topicId: string;
    reputer: string;
    stakeRemovalInfo?: StakeRemovalInfo | undefined;
}
export interface ActorIdTopicIdBlockHeight {
    actorId: string;
    topicId: string;
    blockHeight: string;
}
export interface BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
    blockHeight: string;
    topicId: string;
    delegator: string;
    reputer: string;
    delegateStakeRemovalInfo?: DelegateStakeRemovalInfo | undefined;
}
export interface DelegatorReputerTopicIdBlockHeight {
    delegator: string;
    reputer: string;
    topicId: string;
    blockHeight: string;
}
export interface TopicIdActorIdInference {
    topicId: string;
    actorId: string;
    inference?: Inference | undefined;
}
export interface TopicIdActorIdForecast {
    topicId: string;
    actorId: string;
    forecast?: Forecast | undefined;
}
export interface LibP2pKeyAndOffchainNode {
    libP2pKey: string;
    offchainNode?: OffchainNode | undefined;
}
export interface TopicIdAndDec {
    topicId: string;
    dec: string;
}
export interface TopicIdBlockHeightInferences {
    topicId: string;
    blockHeight: string;
    inferences?: Inferences | undefined;
}
export interface TopicIdBlockHeightForecasts {
    topicId: string;
    blockHeight: string;
    forecasts?: Forecasts | undefined;
}
export interface TopicIdBlockHeightReputerValueBundles {
    topicId: string;
    blockHeight: string;
    reputerValueBundles?: ReputerValueBundles | undefined;
}
export interface TopicIdBlockHeightValueBundles {
    topicId: string;
    blockHeight: string;
    valueBundle?: ValueBundle | undefined;
}
export interface TopicIdAndNonces {
    topicId: string;
    nonces?: Nonces | undefined;
}
export interface TopicIdAndReputerRequestNonces {
    topicId: string;
    reputerRequestNonces?: ReputerRequestNonces | undefined;
}
export interface TopicIdActorIdTimeStampedValue {
    topicId: string;
    actorId: string;
    timestampedValue?: TimestampedValue | undefined;
}
export interface TopicIdActorIdActorIdTimeStampedValue {
    topicId: string;
    actorId1: string;
    actorId2: string;
    timestampedValue?: TimestampedValue | undefined;
}
export interface TopicIdTimestampedActorNonce {
    topicId: string;
    timestampedActorNonce?: TimestampedActorNonce | undefined;
}
export interface BlockHeightTopicIds {
    blockHeight: string;
    topicIds?: TopicIds | undefined;
}
export interface BlockHeightTopicIdWeightPair {
    blockHeight: string;
    topicWeight?: TopicIdWeightPair | undefined;
}
export interface TopicIdReputerReputerValueBundle {
    topicId: string;
    reputer: string;
    reputerValueBundle?: ReputerValueBundle | undefined;
}
export declare const GenesisState: MessageFns<GenesisState>;
export declare const TopicIdAndTopic: MessageFns<TopicIdAndTopic>;
export declare const TopicAndActorId: MessageFns<TopicAndActorId>;
export declare const TopicIdAndBlockHeight: MessageFns<TopicIdAndBlockHeight>;
export declare const BlockHeightAndTopicIds: MessageFns<BlockHeightAndTopicIds>;
export declare const TopicIdBlockHeightScores: MessageFns<TopicIdBlockHeightScores>;
export declare const TopicIdActorIdScore: MessageFns<TopicIdActorIdScore>;
export declare const TopicIdActorIdUint64: MessageFns<TopicIdActorIdUint64>;
export declare const TopicIdActorIdListeningCoefficient: MessageFns<TopicIdActorIdListeningCoefficient>;
export declare const TopicIdActorIdDec: MessageFns<TopicIdActorIdDec>;
export declare const TopicIdAndInt: MessageFns<TopicIdAndInt>;
export declare const TopicIdActorIdInt: MessageFns<TopicIdActorIdInt>;
export declare const TopicIdDelegatorReputerDelegatorInfo: MessageFns<TopicIdDelegatorReputerDelegatorInfo>;
export declare const BlockHeightTopicIdReputerStakeRemovalInfo: MessageFns<BlockHeightTopicIdReputerStakeRemovalInfo>;
export declare const ActorIdTopicIdBlockHeight: MessageFns<ActorIdTopicIdBlockHeight>;
export declare const BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo: MessageFns<BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo>;
export declare const DelegatorReputerTopicIdBlockHeight: MessageFns<DelegatorReputerTopicIdBlockHeight>;
export declare const TopicIdActorIdInference: MessageFns<TopicIdActorIdInference>;
export declare const TopicIdActorIdForecast: MessageFns<TopicIdActorIdForecast>;
export declare const LibP2pKeyAndOffchainNode: MessageFns<LibP2pKeyAndOffchainNode>;
export declare const TopicIdAndDec: MessageFns<TopicIdAndDec>;
export declare const TopicIdBlockHeightInferences: MessageFns<TopicIdBlockHeightInferences>;
export declare const TopicIdBlockHeightForecasts: MessageFns<TopicIdBlockHeightForecasts>;
export declare const TopicIdBlockHeightReputerValueBundles: MessageFns<TopicIdBlockHeightReputerValueBundles>;
export declare const TopicIdBlockHeightValueBundles: MessageFns<TopicIdBlockHeightValueBundles>;
export declare const TopicIdAndNonces: MessageFns<TopicIdAndNonces>;
export declare const TopicIdAndReputerRequestNonces: MessageFns<TopicIdAndReputerRequestNonces>;
export declare const TopicIdActorIdTimeStampedValue: MessageFns<TopicIdActorIdTimeStampedValue>;
export declare const TopicIdActorIdActorIdTimeStampedValue: MessageFns<TopicIdActorIdActorIdTimeStampedValue>;
export declare const TopicIdTimestampedActorNonce: MessageFns<TopicIdTimestampedActorNonce>;
export declare const BlockHeightTopicIds: MessageFns<BlockHeightTopicIds>;
export declare const BlockHeightTopicIdWeightPair: MessageFns<BlockHeightTopicIdWeightPair>;
export declare const TopicIdReputerReputerValueBundle: MessageFns<TopicIdReputerReputerValueBundle>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=genesis.d.ts.map