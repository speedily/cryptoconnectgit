import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"./api.mjs";import{SolanaWalletAddress as o,WalletAddress as n}from"./core.mjs";import"bs58";import"ethers";import"libphonenumber-js/max";const r=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");let s=t.object({address:o.optional(),chain_type:t.literal("solana").optional()}),l=t.object({address:n.optional(),chain_type:t.literal("ethereum").optional()});const d=t.enum(["root","manager"]).nullable(),c=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(s),h=t.object({method:t.literal("signAndSendTransaction"),caip2:r,params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(s),g=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")})}).merge(s);let m=t.string().startsWith("0x"),p=t.union([m,t.number()]);const _=t.object({from:n.optional(),to:n.optional(),chain_id:p.optional(),nonce:p.optional(),data:m.optional(),value:p.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:p.optional(),gas_price:p.optional(),max_fee_per_gas:p.optional(),max_priority_fee_per_gas:p.optional()}),b=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:_})}).merge(l),u=t.object({method:t.literal("eth_sendTransaction"),caip2:r,params:t.object({transaction:_})}).merge(l),j=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}),y=t.object({method:t.literal("personal_sign"),params:j}).merge(l),z=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:t.record(t.string(),t.any()),types:t.record(t.string(),t.any()),message:t.record(t.string(),t.any()),primary_type:t.string()})})}).merge(l),f=t.discriminatedUnion("method",[b,u,y,z]),v=t.discriminatedUnion("method",[c,h,g]),I=t.union([f,v]),k=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),x=t.object({method:t.literal("signAndSendTransaction"),data:t.object({hash:t.string(),caip2:r}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),A=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),T=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),D=t.object({method:t.literal("eth_sendTransaction"),data:t.object({hash:t.string(),caip2:r}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),w=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),U=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),W=t.discriminatedUnion("method",[k,x,A,T,D,w,U]),C=t.object({display_name:t.string().optional(),public_key:t.string(),role:d.optional()});let L=t.union([t.literal("solana"),t.literal("ethereum")]);const M=t.object({id:t.string(),address:t.string(),created_at:t.number(),chain_type:L,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional()}),N=t.object({chain_type:L,policy_ids:t.array(t.string()).max(1).optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional()}).refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),O=t.object({id:t.string(),chain_type:L,address:t.string(),authorization_threshold:t.number().optional()}),S=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),V=t.object({id:t.string()}),q=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:d,created_at:t.number()}),P=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),R=a.extend({chain_type:L.optional()}),Z=t.object({policy_ids:t.array(t.string()).max(1,"Only one policy ID can be set").optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional()}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>null==t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))}));export{q as AuthorizationKeyDashboardResponse,P as AuthorizationKeyResponse,d as AuthorizationKeyRole,r as CAIP2,_ as UnsignedEthereumTransaction,N as WalletApiCreateInput,O as WalletApiCreateResponse,y as WalletApiEthereumPersonalSignRpcInput,j as WalletApiEthereumPersonalSignRpcInputParams,w as WalletApiEthereumPersonalSignRpcResponse,f as WalletApiEthereumRpcInput,u as WalletApiEthereumSendTransactionRpcInput,D as WalletApiEthereumSendTransactionRpcResponse,b as WalletApiEthereumSignTransactionRpcInput,T as WalletApiEthereumSignTransactionRpcResponse,z as WalletApiEthereumSignTypedDataRpcInput,U as WalletApiEthereumSignTypedDataRpcResponse,C as WalletApiRegisterAuthorizationKeyInput,V as WalletApiRevokeAuthorizationKeyInput,I as WalletApiRpcInput,W as WalletApiRpcResponse,v as WalletApiSolanaRpcInput,h as WalletApiSolanaSignAndSendTransactionRpcInput,x as WalletApiSolanaSignAndSendTransactionRpcResponse,g as WalletApiSolanaSignMessageRpcInput,A as WalletApiSolanaSignMessageRpcResponse,c as WalletApiSolanaSignTransactionRpcInput,k as WalletApiSolanaSignTransactionRpcResponse,S as WalletIdFromPath,M as WalletResponse,Z as WalletUpdateInput,R as WalletsSearchInput};
