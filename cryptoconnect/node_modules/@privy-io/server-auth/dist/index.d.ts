import { CustomMetadataType, SmartWalletType, Prettify } from '@privy-io/public-api';
import { Transaction, VersionedTransaction } from '@solana/web3.js';
import * as redaxios from 'redaxios';
import redaxios__default from 'redaxios';

type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
type LinkedAccountType = 'wallet' | 'smart_wallet' | 'email' | 'phone' | 'google_oauth' | 'twitter_oauth' | 'discord_oauth' | 'github_oauth' | 'apple_oauth' | 'linkedin_oauth' | 'tiktok_oauth' | 'spotify_oauth' | 'instagram_oauth' | 'custom_auth' | 'farcaster' | 'telegram' | 'cross_app';
/** @ignore */
interface LinkMetadata {
    /** Account type, most commonly useful when filtering through linkedAccounts */
    type: LinkedAccountType;
    /**
     * @deprecated use `firstVerifiedAt` instead.
     * Datetime when this account was linked to the user or created. */
    verifiedAt: Date;
    /** Datetime when this account was linked to the user. */
    firstVerifiedAt: Date | null;
    /** Datetime when this account was most recently used as a login/link method by the user. */
    latestVerifiedAt: Date | null;
}
/**
 * Object representation of a user's wallet.
 */
interface Wallet {
    /** The wallet address. */
    address: string;
    /**
     * @deprecated Use `chainId` instead.
     *
     * Chain type of the wallet address.
     */
    chainType: 'ethereum' | 'solana';
    /**
     * CAIP-2 formatted chain ID during the most recent verification.
     *
     * e.g. eip155:1, eip155:5, eip155:137, etc.
     */
    chainId?: string;
    /**
     * @deprecated Use `walletClientType` instead.
     */
    walletType?: string;
    /**
     * The wallet client used for this wallet during the most recent verification.
     *
     * If the value is `privy`, then this is a privy embedded wallet.
     *
     * Other values include but are not limited to `metamask`, `rainbow`, `coinbase_wallet`, etc.
     */
    walletClientType?: string;
    /**
     * The connector type used for this wallet during the most recent verification.
     *
     * This includes but is not limited to `injected`, `wallet_connect`, `coinbase_wallet`, `embedded`.
     */
    connectorType?: string;
    /**
     * The index of this wallet for an HD wallet, if the wallet is an embedded wallet.
     */
    hdWalletIndex?: number;
    /**
     * Whether or not this wallet was imported by the user. Will be undefined if the wallet is not
     * an embedded wallet.
     */
    imported?: boolean;
    /**
     * Whether or not this wallet was delegated by the user. Will be undefined if the wallet is not
     * an embedded wallet.
     */
    delegated?: boolean;
}
/** Object representation of a user's email. */
interface Email {
    /** The email address. */
    address: string;
}
/**
 * Object representation of a smart wallet.
 */
interface SmartWallet {
    /** The wallet address. */
    address: string;
    /** The provider of the smart wallet. */
    smartWalletType: SmartWalletType;
}
/** Object representation of a user's phone number. */
interface Phone {
    /** The phone number. */
    number: string;
}
/** Object representation of a user's Google account. */
interface Google {
    /** The `sub` claim from the Google-issued JWT for this account. */
    subject: string;
    /** The email associated with the Google account. */
    email: string;
    /** The name associated with the Google account. */
    name: string | null;
}
/** Object representation of a user's Twitter account. */
interface Twitter {
    /** The `sub` claim from the Twitter-issued JWT for this account. */
    subject: string;
    /** The username associated with the Twitter account. */
    username: string | null;
    /** The name associated with the Twitter account. */
    name: string | null;
    /** The profile picture URL associated with the Twitter account. */
    profilePictureUrl?: string | null;
}
/** Object representation of a user's Discord account. */
interface Discord {
    /** The `sub` claim from the Discord-issued JWT for this account. */
    subject: string;
    /** The username associated with the Discord account.  */
    username: string | null;
    /** The email associated with the Discord account. */
    email: string | null;
}
/** Object representation of a user's Github account. */
interface Github {
    /** The `sub` claim from the Github-issued JWT for this account. */
    subject: string;
    /** The username associated with the Github account.  */
    username: string | null;
    /** The email associated with the Github account. */
    email: string | null;
    /** The name associated with the Github account. */
    name: string | null;
}
/** Object representation of a user's Apple account. */
interface Apple {
    /** The `sub` claim from the Apple-issued JWT for this account. */
    subject: string;
    /** The email associated with the Apple account. */
    email: string;
}
/** Object representation of a user's LinkedIn account. */
interface LinkedIn {
    /** The `sub` claim from the LinkedIn-issued JWT for this account. */
    subject: string;
    /** The email associated with the LinkedIn account. */
    email: string;
    /** The name associated with the LinkedIn account. */
    name: string;
    /** The vanity name associated with the LinkedIn account. */
    vanityName?: string;
}
/** Object representation of a user's Tiktok account. */
interface Tiktok {
    /** The `sub` claim from the Tiktok-issued JWT for this account. */
    subject: string;
    /** The username associated with the Tiktok account. */
    username?: string;
    /** The name associated with the Tiktok account. */
    name: string;
}
interface Spotify {
    /** The `sub` claim from the Spotify-issued JWT for this account. */
    subject: string;
    /** The email associated with the Spotify account. */
    email?: string;
    /** The name associated with the Spotify account. */
    name?: string;
}
interface Instagram {
    /** The `sub` claim from the Instagram-issued JWT for this account. */
    subject: string;
    /** The username associated with the Instagram account. */
    username: string;
}
interface Telegram {
    telegramUserId: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    photoUrl?: string;
}
interface Farcaster {
    fid: number;
    ownerAddress: string;
    username?: string;
    displayName?: string;
    bio?: string;
    pfp?: string;
    url?: string;
}
/** Metadata about the provider app for a cross-app account */
interface ProviderAppMetadata {
    /** Privy app ID for the provider app. */
    id: string;
    /** Name for the provider app. */
    name?: string;
    /** Logo URL for the provider app. */
    logoUrl?: string;
}
interface CrossAppEmbeddedWallet {
    address: string;
}
interface CrossAppSmartWallet {
    address: string;
}
interface CrossAppAccount {
    /** The user's embedded wallet address(es) from the provider app */
    embeddedWallets: CrossAppEmbeddedWallet[];
    smartWallets: CrossAppSmartWallet[];
    providerApp: ProviderAppMetadata;
    subject: string;
}
/** Object representation of a user's Custom JWT account. */
interface CustomJwt {
    /** The `sub` claim (or specified attribute in console configuration) from the Custom JWT for this account. */
    customUserId: string;
}
/** Object representation of a user's email, with additional metadata for advanced use cases. */
interface EmailWithMetadata extends LinkMetadata, Email {
    /** Denotes that this is an email account. */
    type: 'email';
}
/** Object representation of a user's phone number, with additional metadata for advanced use cases. */
interface PhoneWithMetadata extends LinkMetadata, Phone {
    /** Denotes that this is a phone account. */
    type: 'phone';
}
/** Object representation of a user's wallet, with additional metadata for advanced use cases. */
interface WalletWithMetadata extends LinkMetadata, Wallet {
    /** Denotes that this is a wallet account. */
    type: 'wallet';
}
interface SmartWalletWithMetadata extends LinkMetadata, SmartWallet {
    /** Denotes that this is a smart wallet account. */
    type: 'smart_wallet';
}
/** Object representation of a user's Google Account, with additional metadata for advanced use cases. */
interface GoogleOAuthWithMetadata extends LinkMetadata, Google {
    /** Denotes that this is a Google account. */
    type: 'google_oauth';
}
/** Object representation of a user's Twitter Account, with additional metadata for advanced use cases. */
interface TwitterOAuthWithMetadata extends LinkMetadata, Twitter {
    /** Denotes that this is a Twitter account. */
    type: 'twitter_oauth';
}
/** Object representation of a user's Discord Account, with additional metadata for advanced use cases. */
interface DiscordOAuthWithMetadata extends LinkMetadata, Discord {
    /** Denotes that this is a Discord account. */
    type: 'discord_oauth';
}
/** Object representation of a user's Github Account, with additional metadata for advanced use cases. */
interface GithubOAuthWithMetadata extends LinkMetadata, Github {
    /** Denotes that this is a Github account. */
    type: 'github_oauth';
}
/** Object representation of a user's Apple Account, with additional metadata for advanced use cases. */
interface AppleOAuthWithMetadata extends LinkMetadata, Apple {
    /** Denotes that this is a Apple account. */
    type: 'apple_oauth';
}
/** Object representation of a user's LinkedIn Account, with additional metadata for advanced use cases. */
interface LinkedInOAuthWithMetadata extends LinkMetadata, LinkedIn {
    /** Denotes that this is a LinkedIn account. */
    type: 'linkedin_oauth';
}
/** Object representation of a user's Tiktok Account, with additional metadata for advanced use cases. */
interface TiktokOAuthWithMetadata extends LinkMetadata, Tiktok {
    /** Denotes that this is a Tiktok account. */
    type: 'tiktok_oauth';
}
/** Object representation of a user's Spotify Account, with additional metadata for advanced use cases. */
interface SpotifyOAuthWithMetadata extends LinkMetadata, Spotify {
    /** Denotes that this is a Spotify account. */
    type: 'spotify_oauth';
}
/** Object representation of a user's Instagram Account, with additional metadata for advanced use cases. */
interface InstagramOAuthWithMetadata extends LinkMetadata, Instagram {
    /** Denotes that this is an Instagram account. */
    type: 'instagram_oauth';
}
/** Object representation of a user's Custom JWT Account, with additional metadata for advanced use cases. */
interface CustomJwtWithMetadata extends LinkMetadata, CustomJwt {
    /** Denotes that this is a Custom JWT account. */
    type: 'custom_auth';
}
interface FarcasterWithMetadata extends LinkMetadata, Farcaster {
    /** Denotes that this is a Farcaster account. */
    type: 'farcaster';
}
interface TelegramWithMetadata extends LinkMetadata, Telegram {
    /** Denotes that this is a Telegram account. */
    type: 'telegram';
}
/** Object representation of a user's cross-app account, with additional metadata for advanced use cases. */
interface CrossAppAccountWithMetadata extends LinkMetadata, CrossAppAccount {
    /** Denotes that this is a cross-app account */
    type: 'cross_app';
}
/** Generic object representation of a linked account */
type LinkedAccountWithMetadata = WalletWithMetadata | SmartWalletWithMetadata | EmailWithMetadata | PhoneWithMetadata | GoogleOAuthWithMetadata | TwitterOAuthWithMetadata | DiscordOAuthWithMetadata | GithubOAuthWithMetadata | AppleOAuthWithMetadata | LinkedInOAuthWithMetadata | TiktokOAuthWithMetadata | SpotifyOAuthWithMetadata | InstagramOAuthWithMetadata | CustomJwtWithMetadata | FarcasterWithMetadata | TelegramWithMetadata | CrossAppAccountWithMetadata;
type LinkedAccountInput = Array<DistributiveOmit<LinkedAccountWithMetadata, 'verifiedAt' | 'firstVerifiedAt' | 'latestVerifiedAt'>>;
interface CreateWalletInput {
    /** The user's Privy-issued DID. */
    userId: string;
    /** If true, create an Ethereum embedded wallet for this user. Defaults to false. */
    createEthereumWallet?: boolean;
    /** If true, create a Solana embedded wallet for this user. Defaults to false. */
    createSolanaWallet?: boolean;
    /**
     * If true, create a smart wallet for this user. Defaults to false.
     * Requires `createEthereumWallet` to also be true.
     */
    createEthereumSmartWallet?: boolean;
    /**
     * The number of HD Ethereum embedded wallets to create for this user. Defaults to 1.
     * Requires `createEthereumWallet` to also be true.
     */
    numberOfEthereumWalletsToCreate?: number;
}
interface ImportUserInput {
    /** The user's linked accounts. */
    linkedAccounts: LinkedAccountInput;
    /** If true, create an Ethereum embedded wallet for this user. Defaults to false. */
    createEthereumWallet?: boolean;
    /** If true, create a Solana embedded wallet for this user. Defaults to false. */
    createSolanaWallet?: boolean;
    /**
     * If true, create a smart wallet for this user. Defaults to false.
     * Requires `createEthereumWallet` to also be true.
     */
    createEthereumSmartWallet?: boolean;
    /** Custom metadata to associate with the user. */
    customMetadata?: CustomMetadataType;
    /** @deprecated Use `createEthereumWallet` instead. */
    createEmbeddedWallet?: boolean;
}
interface User {
    /** The Privy-issued DID for the user. If you need to store additional information
     * about a user, you can use this DID to reference them. */
    id: string;
    /** The datetime of when the user was created. */
    createdAt: Date;
    /** Whether or not the user is a guest. */
    isGuest: boolean;
    /** Custom metadata set for the user */
    customMetadata: CustomMetadataType;
    /** The user's email address, if they have linked one. It cannot be linked to another user. */
    email?: Omit<EmailWithMetadata, 'type'>;
    /** The user's phone number, if they have linked one. It cannot be linked to another user. */
    phone?: Omit<PhoneWithMetadata, 'type'>;
    /** The user's most recently-linked wallet address, if they have linked at least one wallet.
     * It cannot be linked to another user.
     **/
    wallet?: Omit<WalletWithMetadata, 'type'>;
    /**
     * The user's smart wallet, if they have set up through the Privy Smart Wallet SDK.
     */
    smartWallet?: Omit<SmartWalletWithMetadata, 'type'>;
    /** The user's Google account, if they have linked one. It cannot be linked to another user. */
    google?: Omit<GoogleOAuthWithMetadata, 'type'>;
    /** The user's Twitter account, if they have linked one. It cannot be linked to another user. */
    twitter?: Omit<TwitterOAuthWithMetadata, 'type'>;
    /** The user's Discord account, if they have linked one. It cannot be linked to another user. */
    discord?: Omit<DiscordOAuthWithMetadata, 'type'>;
    /** The user's Github account, if they have linked one. It cannot be linked to another user. */
    github?: Omit<GithubOAuthWithMetadata, 'type'>;
    /** The user's Apple account, if they have linked one. It cannot be linked to another user. */
    apple?: Omit<AppleOAuthWithMetadata, 'type'>;
    /** The user's Tiktok account, if they have linked one. It cannot be linked to another user. */
    tiktok?: Omit<TiktokOAuthWithMetadata, 'type'>;
    /** The user's LinkedIn account, if they have linked one. It cannot be linked to another user. */
    linkedin?: Omit<LinkedInOAuthWithMetadata, 'type'>;
    /** The user's Spotify account, if they have linked one. It cannot be linked to another user. */
    spotify?: Omit<SpotifyOAuthWithMetadata, 'type'>;
    /** The user's Instagram account, if they have linked one. It cannot be linked to another user. */
    instagram?: Omit<InstagramOAuthWithMetadata, 'type'>;
    /** The user's Custom JWT account, if they have linked one. It cannot be linked to another user. */
    custom?: Omit<CustomJwtWithMetadata, 'type'>;
    /** The user's Farcaster account, if they have linked one. It cannot be linked to another user. */
    farcaster?: Omit<FarcasterWithMetadata, 'type'>;
    /** The user's Telegram account, if they have linked one. It cannot be linked to another user. */
    telegram?: Omit<TelegramWithMetadata, 'type'>;
    /** The list of accounts associated with this user. Each account contains additional metadata
     * that may be helpful for advanced use cases. */
    linkedAccounts: Array<LinkedAccountWithMetadata>;
}
interface AppSettings {
    id?: string;
    name?: string;
    verificationKey: string;
    logoUrl?: string;
    theme?: 'System' | 'Light' | 'Dark' | string;
    accentColor?: string;
    walletAuth?: boolean;
    emailAuth?: boolean;
    smsAuth?: boolean;
    googleOAuth?: boolean;
    twitterOAuth?: boolean;
    discordOAuth?: boolean;
    githubOAuth?: boolean;
    appleOAuth?: boolean;
    linkedInOAuth?: boolean;
    tiktokOAuth?: boolean;
    disablePlusEmails?: boolean;
    allowlistEnabled: boolean;
    allowlistConfig: {
        errorTitle: string | null;
        errorDetail: string | null;
        ctaText: string | null;
        ctaLink: string | null;
    };
    termsAndConditionsUrl: string | null;
    privacyPolicyUrl: string | null;
    createdAt?: Date;
    updatedAt?: Date;
}
interface AuthTokenClaims {
    appId: string;
    issuer: string;
    issuedAt: number;
    expiration: number;
    sessionId: string;
    userId: string;
}
type AllowlistEntryType = 'email' | 'phone' | 'wallet';
interface AllowlistEntry {
    id: string;
    type: AllowlistEntryType;
    value: string;
    appId: string;
}
type AllowlistEntryInput = Pick<AllowlistEntry, 'type' | 'value'>;
/**
 * Get multiple users by email, phone number, and wallet address.
 */
type BulkParams = {
    /** Get users by email addresses. Use this for getting multiple users by email address. */
    emails?: string[];
    /** Get users by phone number. Use this for getting multiple users by phone number */
    phoneNumbers?: string[];
    /** Get users by wallet address. Use this for getting multiple users by wallet address */
    walletAddresses?: string[];
};
/** Object containing the relevant headers of an incoming webhook */
type WebhooksVerificationHeaderInput = {
    id: string;
    timestamp: string;
    signature: string;
};

interface DefaultsType {
    baseURL: string;
    timeout: number;
}
type Axios = typeof redaxios__default;
type AxiosRequestConfig = Parameters<Axios>[1];
declare class Http {
    private instance;
    private sdkVersion;
    baseURL: string;
    constructor(appId: string, appSecret: string, { baseURL, timeout }: DefaultsType);
    get<T>(path: string, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    post<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    delete<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
}

type WalletApiCreateResponseType = {
    /** Unique ID for the created wallet. Used to take actions with the wallet after creation. */
    id: string;
    /** Chain type for the created wallet. */
    chainType: 'ethereum' | 'solana';
    /** Address for the created wallet */
    address: string;
    /** The optional authorization threshold for the wallet. */
    authorizationThreshold?: number;
};
/**
 * Helper type to insert the following fields into RPC bodies depending on how they are used:
 * - Delegated actions: adds {address: string; chainType: 'solana' | 'ethereum'}
 * - Server wallets: adds {walletId: string}
 *
 */
type WithWalletIdOrAddressChainType<T, U extends 'solana' | 'ethereum'> = Prettify<T & {
    /** Address of the wallet. */
    address: string;
    /** Chain type of the wallet. */
    chainType: U;
}> | Prettify<T & {
    /** ID of the wallet. */
    walletId: string;
}>;
/**
 * Helper to insert an idempotencyKey field into request bodies
 */
type WithOptionalIdempotencyKey<T> = Prettify<T & {
    idempotencyKey?: string;
}>;

type Hex = `0x${string}`;
type Quantity = Hex | number;
type EthereumRpcWrapper<T> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<T, 'ethereum'>>;
/**
 * CAIP-2 chain IDs for EVM networks.
 */
type EvmCaip2ChainId = `eip155:${string}`;
/**
 * Inputs for the `privy.walletApi.ethereum.signMessage(...) method.
 */
type EthereumSignMessageInputType = EthereumRpcWrapper<{
    /** Message to sign as a UTF-8 string, a hex string, or an array of bytes. */
    message: string | Uint8Array;
}>;
/**
 * Inputs for the `privy.walletApi.ethereum.signTypedData(...) method.
 */
type EthereumSignTypedDataInputType = EthereumRpcWrapper<{
    /** EIP712 typed data to sign. */
    typedData: {
        domain: Record<string, any>;
        types: Record<string, any>;
        message: Record<string, any>;
        primaryType: string;
    };
}>;
type EthereumBaseTransactionInputType = {
    transaction: {
        /** The address the transaction is sent from. Must be hexadecimal formatted. */
        from?: Hex;
        /** Destination address of the transaction. */
        to?: Hex;
        /** The nonce to be used for the transaction (hexadecimal or number). */
        nonce?: Quantity;
        /** (optional) The chain ID of network your transaction will  be sent on. */
        chainId?: Quantity;
        /** (optional) Data to send to the receiving address, especially when calling smart contracts. Must be hexadecimal formatted. */
        data?: Hex;
        /** (optional) The value (in wei) be sent with the transaction (hexadecimal or number). */
        value?: Quantity;
        /** (optional) The EIP-2718 transction type (e.g. `2` for EIP-1559 transactions). */
        type?: 0 | 1 | 2;
        /** (optional) The max units of gas that can be used by this transaction (hexadecimal or number). */
        gasLimit?: Quantity;
        /** (optional) The price (in wei) per unit of gas for this transaction (hexadecimal or number), for use in non EIP-1559 transactions (type 0 or 1). */
        gasPrice?: Quantity;
        /** (optional) The maxFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
        maxFeePerGas?: Quantity;
        /** (optional) The maxPriorityFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
        maxPriorityFeePerGas?: Quantity;
    };
};
/**
 * Inputs for the `privy.walletApi.ethereum.signTransaction(...) method.
 */
type EthereumSignTransactionInputType = EthereumRpcWrapper<EthereumBaseTransactionInputType>;
/**
 * Inputs for the `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type EthereumSendTransactionInputType = EthereumRpcWrapper<EthereumBaseTransactionInputType & {
    /** CAIP-2 chain ID for the network to broadcast the transaction on. */
    caip2: EvmCaip2ChainId;
}>;
type EthereumRpcInputTypes = EthereumSignMessageInputType | EthereumSignTypedDataInputType | EthereumSignTransactionInputType | EthereumSendTransactionInputType;
/** Response for the `privy.walletApi.ethereum.signMessage(...) method. */
type EthereumSignMessageResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.signTypedData(...) method. */
type EthereumSignTypedDataResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.signTransaction(...) method. */
type EthereumSignTransactionResponseType = {
    /** Signed transaction by the wallet. */
    signedTransaction: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.sendTransaction(...) method. */
type EthereumSendTransactionResponseType = {
    /** Hash for the broadcasted transaction. */
    hash: string;
    /** CAIP-2 chain ID for the network the transaction was broadcasted on. */
    caip2: EvmCaip2ChainId;
};

declare class EthereumRpcApi {
    private appId;
    private api;
    private authorizationPrivateKey;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey: bigint | null;
    });
    /**
     * Method to sign a message with an Ethereum wallet using the 'personal_sign' RPC.
     *
     * @param input {EthereumSignMessageInputType} message to sign
     * @returns {EthereumSignMessageResponseType} signature and encoding of signature
     */
    signMessage(input: EthereumSignMessageInputType): Promise<EthereumSignMessageResponseType>;
    /**
     * Method to sign an EIP712 typed data message with an Ethereum wallet using the
     * 'eth_signTypedData_v4' RPC.
     *
     * @param input {EthereumSignTypedData} typed data message to sign
     * @returns {EthereumSignTypedDataResponseType} signature and encoding of signature
     */
    signTypedData(input: EthereumSignTypedDataInputType): Promise<EthereumSignTypedDataResponseType>;
    /**
     * Method to sign a transaction with an Ethereum wallet using the 'eth_signTransaction' RPC.
     *
     * @param input {EthereumSignTransactionInputType} transaction to sign
     * @returns {EthereumSignTransactionResponseType} signed transaction and encoding of signature
     */
    signTransaction(input: EthereumSignTransactionInputType): Promise<EthereumSignTransactionResponseType>;
    /**
     * Method to sign and send a transaction with an Ethereum wallet using the
     * 'eth_sendTransaction' RPC.
     *
     * @param input {EthereumSendTransactionInputType} transaction to send and CAIP-2 chain ID for the transaction
     * @returns {EthereumSendTransactionResponseType} transaction hash and CAIP-2 chain ID for the transaction's network
     */
    sendTransaction(input: EthereumSendTransactionInputType): Promise<EthereumSendTransactionResponseType>;
}

/**
 * CAIP-2 chain IDs for Solana mainnet, devnet, and testnet
 *
 * - Mainnet: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'
 * - Devnet: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
 * - Testnet: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z'
 */
type SolanaCaip2ChainId = 
/** Solana mainnet CAIP-2 chain ID */
'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'
/** Solana devnet CAIP-2 chain ID */
 | 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
/** Solana testnet CAIP-2 chain ID */
 | 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z';
type SolanaRpcWrapper<T> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<T, 'ethereum'>>;
/** Input for the `privy.walletApi.solana.signMessage(...)` method. */
type SolanaSignMessageInputType = SolanaRpcWrapper<{
    /** Message to sign with the wallet. */
    message: string | Uint8Array;
}>;
/** Input for the `privy.walletApi.solana.signTransaction(...)` method. */
type SolanaSignTransactionInputType = SolanaRpcWrapper<{
    /** Transaction object to sign with the wallet */
    transaction: Transaction | VersionedTransaction;
}>;
/** Input for the `privy.walletApi.solana.sendTransaction(...)` method. */
type SolanaSignAndSendTransactionInputType = SolanaRpcWrapper<{
    /** Transaction object to sign with the wallet */
    transaction: Transaction | VersionedTransaction;
    /** CAIP-2 chain ID for the Solana network to broadcast the transaction on. */
    caip2: SolanaCaip2ChainId;
}>;
type SolanaRpcInputTypes = SolanaSignMessageInputType | SolanaSignTransactionInputType | SolanaSignAndSendTransactionInputType;
/** Response  for the `privy.walletApi.solana.signMessage(...)` method. */
type SolanaSignMessageResponseType = {
    /** Signature produced by the wallet. */
    signature: Uint8Array;
};
/** Response for the `privy.walletApi.solana.signTransaction(...)` method. */
type SolanaSignTransactionResponseType = {
    /** Signed transaction object. */
    signedTransaction: Transaction | VersionedTransaction;
};
/** Response for the `privy.walletApi.solana.signAndSendTransaction(...) method. */
type SolanaSignAndSendTransactionResponseType = {
    /** Hash for the broadcasted transaction. */
    hash: string;
    /** CAIP-2 chain ID for the network the transaction was broadcasted on. */
    caip2: SolanaCaip2ChainId;
};

/**
 * @deprecated Use `SolanaSignMessageInputType` instead with the
 * `privy.walletApi.solana.signMessage(...) method.
 */
type SolanaSignMessageRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'signMessage';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** Message to sign with the wallet. */
        message: string | Uint8Array;
    };
}, 'solana'>>;
type SolanaBaseTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = {
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** transaction object to sign with the wallet */
        transaction: TTransactionType;
    };
};
/**
 * @deprecated Use `SolanaSignTransactionInputType` instead with the
 * `privy.walletApi.solana.signTransaction(...) method.
 *
 * The input parameters for the `signTransaction` RPC method to sign a Solana transaction.
 * If you use this type directly you can optionally narrow it to just `Transaction` or `VersionedTransaction`,
 * like `SolanaSignTransactionRpcInputType<VersionedTransaction>`.
 * Otherwise, the `rpc` method will determine the type of transaction you passed in and return the appropriate type.
 */
type SolanaSignTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<SolanaBaseTransactionRpcInputType<TTransactionType> & {
    /** RPC method to execute with the wallet.  */
    method: 'signTransaction';
}, 'solana'>>;
/**
 *  * @deprecated Use `SolanaSignAndSendTransactionInputType` instead with the
 * `privy.walletApi.solana.signAndSendTransaction(...) method.
 *
 * The input parameters for the `signAndSendTransaction` RPC method to sign a Solana transaction.
 * If you use this type directly you can optionally narrow it to just `Transaction` or `VersionedTransaction`,
 * like `SolanaSignAndSendTransactionRpcInputType<VersionedTransaction>`.
 * Otherwise, the `rpc` method will determine the type of transaction you passed in and return the appropriate type.
 */
type SolanaSignAndSendTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<SolanaBaseTransactionRpcInputType<TTransactionType> & {
    /** RPC method to execute with the wallet.  */
    method: 'signAndSendTransaction';
    /**
     * CAIP-2 chain ID for the Solana network to broadcast the transaction on.
     **/
    caip2: SolanaCaip2ChainId;
}, 'solana'>>;
/**
 * @deprecated Use `EthereumSignTypedDataInputType` instead with the
 * `privy.walletApi.ethereum.signTypedData(...) method.
 */
type EthereumSignTypedDataRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'eth_signTypedData_v4';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        typedData: {
            domain: Record<string, any>;
            types: Record<string, any>;
            message: Record<string, any>;
            primaryType: string;
        };
    };
}, 'ethereum'>>;
/**
 * @deprecated Use `EthereumSignMessageInputType` instead with the
 * `privy.walletApi.ethereum.signMessage(...) method.
 */
type EthereumPersonalSignRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'personal_sign';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        message: string | Uint8Array;
    };
}, 'ethereum'>>;
type EthereumBaseTransactionRpcInputType = {
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** The transaction object to sign with the wallet. */
        transaction: {
            /** The address the transaction is sent from. Must be hexadecimal formatted. */
            from?: Hex;
            /** Destination address of the transaction. */
            to?: Hex;
            /** The nonce to be used for the transaction (hexadecimal or number). */
            nonce?: Quantity;
            /** (optional) The chain ID of network your transaction will  be sent on. */
            chainId?: Quantity;
            /** (optional) Data to send to the receiving address, especially when calling smart contracts. Must be hexadecimal formatted. */
            data?: Hex;
            /** (optional) The value (in wei) be sent with the transaction (hexadecimal or number). */
            value?: Quantity;
            /** (optional) The EIP-2718 transction type (e.g. `2` for EIP-1559 transactions). */
            type?: 0 | 1 | 2;
            /** (optional) The max units of gas that can be used by this transaction (hexadecimal or number). */
            gasLimit?: Quantity;
            /** (optional) The price (in wei) per unit of gas for this transaction (hexadecimal or number), for use in non EIP-1559 transactions (type 0 or 1). */
            gasPrice?: Quantity;
            /** (optional) The maxFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
            maxFeePerGas?: Quantity;
            /** (optional) The maxPriorityFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
            maxPriorityFeePerGas?: Quantity;
        };
    };
};
/**
 * @deprecated Use `EthereumSignTransactionInputType` instead with the
 * `privy.walletApi.ethereum.signTransaction(...) method.
 */
type EthereumSignTransactionRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<EthereumBaseTransactionRpcInputType & {
    /** RPC method to execute with the wallet.  */
    method: 'eth_signTransaction';
}, 'ethereum'>>;
/**
 * @deprecated Use `EthereumSendTransactionInputType` instead with the
 * `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type EthereumSendTransactionRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<EthereumBaseTransactionRpcInputType & {
    /** RPC method to execute with the wallet.  */
    method: 'eth_sendTransaction';
    /** CAIP-2 chain ID for the EVM network to broadcast the transaction on. */
    caip2: EvmCaip2ChainId;
}, 'ethereum'>>;
type WalletApiRpcInputType = SolanaSignMessageRpcInputType | SolanaSignTransactionRpcInputType | SolanaSignAndSendTransactionRpcInputType | EthereumSignTypedDataRpcInputType | EthereumPersonalSignRpcInputType | EthereumSignTransactionRpcInputType | EthereumSendTransactionRpcInputType;
/**
 * @deprecated Use `SolanaSignTransactionResponseType` instead from the
 * `privy.walletApi.solana.signTransaction(...) method.
 */
type WalletApiSolanaSignTransactionRpcResponseType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = {
    /** RPC method executed by the wallet. */
    method: 'signTransaction';
    /** Data returned from the RPC method. */
    data: {
        /** Signed transaction object produced by the wallet. */
        signedTransaction: TTransactionType;
    };
};
/**
 * @deprecated Use `SolanaSignAndSendTransactionResponseType` instead from the
 * `privy.walletApi.solana.signAndSendTransaction(...) method.
 */
type WalletApiSolanaSignAndSendTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'signAndSendTransaction';
} & ({
    /** Data returned from the RPC method. */
    data: {
        /** Transaction hash. */
        hash: string;
        /** CAIP-2 chain ID of the Solana network the transaction was broadcasted on. */
        caip2: SolanaCaip2ChainId;
    };
} | {
    error: {
        /** Error code. */
        code: string;
        /** Error message. */
        message: string;
    };
});
/**
 * @deprecated Use `SolanaSignMessageResponseType` instead from the
 * `privy.walletApi.solana.signMessage(...) method.
 */
type WalletApiSolanaSignMessageRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'signMessage';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: Uint8Array;
    };
};
/**
 * @deprecated Use `EthereumSignTypedDataResponseType` instead from the
 * `privy.walletApi.ethereum.signTypedData(...) method.
 */
type WalletApiEthereumSignTypedDataRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_signTypedData_v4';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: string;
        /** Encoding of the signature. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSignMessageResponseType` instead from the
 * `privy.walletApi.ethereum.signMessage(...) method.
 */
type WalletApiEthereumPersonalSignRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'personal_sign';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: string;
        /** Encoding of the signature. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSignTransactionResponseType` instead from the
 * `privy.walletApi.ethereum.signTransaction(...) method.
 */
type WalletApiEthereumSignTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_signTransaction';
    /** Data returned from the RPC method. */
    data: {
        /** Signed transaction object produced by the wallet. */
        signedTransaction: string;
        /** Encoding of the signed transaction. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSendTransactionResponseType` instead from the
 * `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type WalletApiEthereumSendTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_sendTransaction';
} & ({
    /** Data returned from the RPC method. */
    data: {
        /** Transaction hash. */
        hash: string;
        /** CAIP-2 chain ID of the EVM network the transaction was broadcasted on. */
        caip2: EvmCaip2ChainId;
    };
} | {
    error: {
        /** Error code. */
        code: string;
        /** Error message. */
        message: string;
    };
});
type WalletApiRpcResponseType = WalletApiSolanaSignTransactionRpcResponseType | WalletApiSolanaSignMessageRpcResponseType | WalletApiSolanaSignAndSendTransactionRpcResponseType | WalletApiEthereumSignTypedDataRpcResponseType | WalletApiEthereumPersonalSignRpcResponseType | WalletApiEthereumSignTransactionRpcResponseType | WalletApiEthereumSendTransactionRpcResponseType;

type WalletApiCreateRequestType = WithOptionalIdempotencyKey<{
    chainType: 'ethereum' | 'solana';
    authorizationKeyIds?: string[];
    authorizationThreshold?: number;
}>;
type WalletApiRpcInputTypes = EthereumRpcInputTypes | SolanaRpcInputTypes;
type WalletApiWalletResponseType = {
    /** Unique ID for the created wallet. Used to take actions with the wallet after creation. */
    id: string;
    /** Chain type for the created wallet. */
    chainType: 'ethereum' | 'solana';
    /** Address for the created wallet */
    address: string;
    /** Policy IDs that have been assigned to the wallet. */
    policyIds: string[];
    /** The creation date of the wallet */
    createdAt: Date;
};
type WalletApiFindWalletsRequestType = {
    /** Cursor used to paginate results */
    cursor?: string;
    /** Maximum results per page */
    limit?: number;
    /** Chain type to filter by. */
    chainType?: 'ethereum' | 'solana';
};
type WalletApiFindWalletsResponseType = {
    /** List of wallets */
    data: Array<WalletApiWalletResponseType>;
    /** Cursor for the next page */
    nextCursor?: string;
};

declare class SolanaRpcApi {
    private appId;
    private api;
    private authorizationPrivateKey;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey: bigint | null;
    });
    /**
     * Method to sign a message with an Solana wallet using the 'signMessage' RPC.
     *
     * @param input {SolanaSignMessageInputType} message to sign
     * @returns {SolanaSignMessageResponseType} signature and encoding of signature
     */
    signMessage(input: SolanaSignMessageInputType): Promise<SolanaSignMessageResponseType>;
    /**
     * Method to sign a transaction with an Solana wallet using the 'signTransaction' RPC.
     *
     * @param input {SolanaSignTransactionInputType} transaction to sign
     * @returns {SolanaSignTransactionResponseType} signed transaction
     */
    signTransaction(input: SolanaSignTransactionInputType): Promise<{
        signedTransaction: Transaction | VersionedTransaction;
    }>;
    /**
     * Method to sign and send a transaction with an Solana wallet using the 'signAndSendTransaction' RPC.
     *
     * @param input {SolanaSignAndSendTransactionType} transaction to sign and broadcast
     * @returns {SolanaSignAndSendTransactionResponseType} transaction hash
     */
    signAndSendTransaction(input: SolanaSignAndSendTransactionInputType): Promise<{
        hash: string;
        caip2: SolanaCaip2ChainId;
    }>;
}

/**
 * Class to support making RPC requests to the Privy wallets API. When the Privy client
 * is constructed, this class is also constructed and will be set as the `.walletApi` field
 * for the client.
 */
declare class WalletApi {
    private appId;
    private api;
    private authorizationPrivateKey;
    ethereum: EthereumRpcApi;
    solana: SolanaRpcApi;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey?: string;
    });
    getWallets(input?: WalletApiFindWalletsRequestType): Promise<WalletApiFindWalletsResponseType>;
    getWallet({ id, }: {
        /** ID for the wallet to fetch. */
        id: string;
    }): Promise<WalletApiWalletResponseType>;
    create(input: WalletApiCreateRequestType): Promise<WalletApiCreateResponseType>;
    /**
     * @deprecated Use specific methods on the `privy.walletApi.ethereum` and `privy.walletApi.solana` classes instead:
     * - `privy.walletApi.ethereum.{signMessage, signTypedData, signTransaction, sendTransaction}`
     * - `privy.walletApi.solana.{signMessage, signTransaction, signAndSendTransaction}`
     *
     * Executed RPC requests for the provided wallet.
     *
     * @returns data returned by executed RPC method
     */
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType<Transaction>): Promise<WalletApiSolanaSignTransactionRpcResponseType<Transaction>>;
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType<VersionedTransaction>): Promise<WalletApiSolanaSignTransactionRpcResponseType<VersionedTransaction>>;
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType): Promise<WalletApiSolanaSignTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType<Transaction>): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType<VersionedTransaction>): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signMessage';
    } & SolanaSignMessageRpcInputType): Promise<WalletApiSolanaSignMessageRpcResponseType>;
    rpc(input: {
        method: 'eth_signTransaction';
    } & EthereumSignTransactionRpcInputType): Promise<WalletApiEthereumSignTransactionRpcResponseType>;
    rpc(input: {
        method: 'personal_sign';
    } & EthereumPersonalSignRpcInputType): Promise<WalletApiEthereumPersonalSignRpcResponseType>;
    rpc(input: {
        method: 'eth_signTypedData_v4';
    } & EthereumSignTypedDataRpcInputType): Promise<WalletApiEthereumSignTypedDataRpcResponseType>;
    rpc(input: {
        method: 'eth_sendTransaction';
    } & EthereumSendTransactionRpcInputType): Promise<WalletApiEthereumSendTransactionRpcResponseType>;
}

/**
 * The Privy client performs operations against the Privy API.
 *
 * ```typescript
 * import {PrivyClient} from '@privy-io/server-auth';
 * ```
 */
declare class PrivyClient {
    private api;
    private appId;
    private verificationKey;
    walletApi: WalletApi;
    /**
     * Creates a new Privy client.
     *
     * @param appId The app id from your console.
     * @param appSecret The app secret, only visible once on app creation in the console.
     * @param options Initialization options.
     */
    constructor(appId: string, appSecret: string, options?: {
        /**
         * The URL of the Privy API. Defaults to `https://auth.privy.io`.
         */
        apiURL?: string;
        /**
         * Time in milliseconds after which to timeout requests to the API. Defaults to `10000` (10 seconds).
         */
        timeout?: number;
        /**
         * Configuration for Privy's wallet API.
         */
        walletApi?: {
            /**
             * Private key for your app's authorization keypair.
             *
             * If your app has an authorization keypair registered in the Privy
             * Dashboard, you must pass the corresponding private key here, otherwise
             * wallet RPC requests will fail.
             */
            authorizationPrivateKey?: string;
            /**
             * The URL of the wallets API. Defaults to `https://api.privy.io`.
             */
            apiURL?: string;
        };
    });
    /**
     * Gets a user from the identity token. First, this verifies the token is valid and then parses
     * the payload into a `User` object. Note the user object may be incomplete due to identity token
     * size constraints
     *
     * ```typescript
     * const idToken = req.cookies.get('privy-id-token'); // or however your framework surfaces cookies
     * const user = await client.getUser({idToken});
     * ```
     *
     * @param props.idToken the identity token set as a cookie on the users browser
     * @returns the user object with parsed from the ID token
     */
    getUser(props: {
        idToken: string;
    }): Promise<User>;
    /**
     * @deprecated This method is subject to strict rate limits. Please use getUser({idToken: string}) to avoid rate limits as your app scales.
     *
     * Get the user object associated with the given user DID (decentralized ID).
     *
     * @param userId The Privy DID of the user.
     * @returns A {@link User} if the user exists.
     */
    getUser(userId: string): Promise<User>;
    /**
     * ATTENTION: This method is subject to strict rate limits. Please use getUser({idToken: string}) to avoid rate limits as your app scales.
     */
    getUserById(userId: string): Promise<User>;
    /**
     * Get the user object associated with an email address.
     *
     * ```typescript
     * const user = await client.getUserByEmail(emailAddress);
     * ```
     *
     * @param address The email address of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserByEmail(address: string): Promise<User | null>;
    /**
     * Get the user object associated with a phone number.
     *
     * ```typescript
     * const user = await client.getUserByPhoneNumber(number);
     * ```
     *
     * @param number The phone number of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserByPhoneNumber(number: string): Promise<User | null>;
    /**
     * Get the user object associated with a wallet address.
     *
     * ```typescript
     * const user = await client.getUserByWalletAddress(walletAddress);
     * ```
     *
     * @param walletAddress The wallet address of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserByWalletAddress(walletAddress: string): Promise<User | null>;
    /**
     * Get the user object associated with a smart wallet address.
     *
     * ```typescript
     * const user = await client.getUserBySmartWalletAddress(walletAddress);
     * ```
     *
     * @param walletAddress The smart wallet address of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserBySmartWalletAddress(walletAddress: string): Promise<User | null>;
    /**
     * Get the user object associated with a farcaster ID.
     *
     * ```typescript
     * const user = await client.getUserByFarcasterId(fid);
     * ```
     *
     * @param fid The farcaster ID (a number).
     * @returns A {@link User} if the user exists.
     */
    getUserByFarcasterId(fid: number): Promise<User | null>;
    /**
     * Get the user object associated with a Discord username.
     *
     * ```typescript
     * const user = await client.getUserByDiscordUsername(username);
     * ```
     *
     * @param username Discord username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByDiscordUsername(username: string): Promise<User | null>;
    /**
     * Get the user object associated with a Github username.
     *
     * ```typescript
     * const user = await client.getUserByGithubUsername(username);
     * ```
     *
     * @param username Github username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByGithubUsername(username: string): Promise<User | null>;
    /**
     * Get the user object associated with a twitter username.
     *
     * ```typescript
     * const user = await client.getUserByTwitterUsername(username);
     * ```
     *
     * @param username Twitter username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTwitterUsername(username: string): Promise<User | null>;
    /**
     *
     * Get the user object associated with a twitter oauth subject (ID).
     * ```typescript
     * const user = await client.getUserByTwitterSubject(subject);
     * ```
     *
     * @param subject Twitter subject to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTwitterSubject(subject: string): Promise<User | null>;
    /**
     * Get the user object associated with a telegram user ID.
     * ```typescript
     * const user = await client.getUserByTelegramUserId(telegramUserId);
     * ```
     *
     * @param telegramUserId Telegram user ID to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTelegramUserId(telegramUserId: string): Promise<User | null>;
    /**
     * Get the user object associated with a telegram username.
     * ```typescript
     * const user = await client.getUserByTelegramUsername(telegramUsername);
     * ```
     * @param username Telegram username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTelegramUsername(username: string): Promise<User | null>;
    /**
     * Gets a user object by their custom JWT auth ID, which
     * is scoped to an individual app.
     *
     * ```typescript
     * const user = await client.getUserByCustomAuthId(customUserId);
     * ```
     *
     * @param customUserId The custom identifier of the user defined by their JWT
     * @returns A {@link User} if the user exists.
     */
    getUserByCustomAuthId(customUserId: string): Promise<User | null>;
    /**
     * Get the list of users associated with this app.
     *
     * ```typescript
     * const users = await client.getUsers();
     * ```
     *
     * @returns A list of users.
     */
    getUsers(): Promise<Array<User>>;
    /**
     * Get the list of users associated with this app whose email,
     * phone number, wallet address, name, or username match a search term.
     *
     * ```typescript
     * const users = await client.getUsers("@privy.io");
     * ```
     *
     * @param searchTerm (optional) The value used to search the list of users.
     * @returns A list of users.
     *
     * @deprecated Use custom helper functions to search
     */
    getUsers(searchTerm: string): Promise<Array<User>>;
    /**
     * Get multiple users associated with this app by email, phone number, and wallet address
     *
     * ```typescript
     * const users = await client.getUsers({
     *     emails: ["user1@privy.io", "user2@privy.io"]
     * });
     * ```
     *
     * @param bulkParams The values used to search the list of users.
     * @returns A list of users.
     */
    getUsers(bulkParams: BulkParams): Promise<Array<User>>;
    /**
     * Delete the user object associated with the given user DID (decentralized ID).
     *
     * ```typescript
     * const user = await client.deleteUser("did:privy:XXXXX");
     * ```
     *
     * @param userId The Privy DID of the user.
     */
    deleteUser(userId: string): Promise<void>;
    /**
     * Import existing user data into Privy, including their linked account data.
     *
     * This allows your users to interact with all their linked accounts normally after your migration to Privy.
     *
     * ```typescript
     * const user = await client.importUser({
     *  createEthereumWallet: false,
     *  createSolanaWallet: false,
     *  createEthereumSmartWallet: false,
     *  linkedAccounts: [
     *    {
     *      "subject": "123456789123456789",
     *      "username": "batman#1234",
     *      "email": "batman@gmail.com",
     *      "type": "discord_oauth"
     *    },
     *    {
     *      "number": "+1 123 456 7890",
     *      "type": "phone"
     *    },
     *    {
     *      "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
     *      "type": "wallet",
     *      "chainType": "ethereum"
     *    }
     * ]);
     * ```
     *
     * @param importUserInput The user object {@link ImportUserInput}, containing linked accounts to import.
     * @returns The resultant user {@link User} object.
     */
    importUser({ linkedAccounts, createEthereumWallet, createSolanaWallet, createEthereumSmartWallet, customMetadata, createEmbeddedWallet, }: ImportUserInput): Promise<User>;
    /**
     * Create embedded and smart wallets for an existing user on Privy.
     *
     * ```typescript
     * const user = await client.createWallets({
     *  createEthereumWallet: true,
     *  createSolanaWallet: false,
     *  createEthereumSmartWallet: true,
     *  numberOfEthereumWalletsToCreate: 2
     * });
     * ```
     */
    createWallets({ userId, createEthereumWallet, createSolanaWallet, createEthereumSmartWallet, numberOfEthereumWalletsToCreate, }: CreateWalletInput): Promise<User>;
    /**
     * Get the app settings associated with the given app.
     *
     * @returns the {@link AppSettings}
     */
    getAppSettings(): Promise<AppSettings>;
    /**
     * Get the allowlist entries for a the given app. This is a list of users that are allowed to access the app,
     * if the allowlist is enabled.
     *
     *
     * ```typescript
     * const allowlist = await client.getAllowlist();
     * ```
     *
     * @returns a list of {@link AllowlistEntry} objects.
     */
    getAllowlist(): Promise<AllowlistEntry[]>;
    /**
     * Add an allowlist entry for the given app, to give that user access.
     *
     * The allowlist must enabled for the app, otherwise this will fail.
     *
     *
     * ```typescript
     * const entry = await client.inviteToAllowlist({ type: 'email', value: 'batman@privy.io'});
     * ```
     * @param allowlistEntry The {@link AllowlistEntryInput} to add to the allowlist.
     * @returns the created {@link AllowlistEntry} object.
     */
    inviteToAllowlist(allowlistEntry: AllowlistEntryInput): Promise<AllowlistEntry>;
    /**
     * Remove an entry from the allowlist for a Privy app.
     *
     * The allowlist must enabled for the app, otherwise this will fail.
     *
     * ```typescript
     * await client.removeFromAllowlist();
     * ```
     *
     * @param allowlistEntry The {@link AllowlistEntryInput} to remove from the allowlist.
     * @returns the deleted {@link AllowlistEntry} object.
     */
    removeFromAllowlist(allowlistEntry: AllowlistEntryInput): Promise<AllowlistEntry>;
    /**
     * Verify the auth token format, signature, and claims.
     *
     * Example usage given e.g. a `NextApiRequest` request:
     * ```typescript
     * const header = request.headers.authorization;
     * const token = header.replace(/^Bearer /, '');
     * const verifiedClaims = await verifyAuthToken(token);
     * ```
     *
     * @param token The auth token (JWT).
     * @param verificationKeyOverride Overrides the default ES256 JWT verification key loaded from app settings.
     * @returns Object containing auth token claims.
     */
    verifyAuthToken(token: string, verificationKeyOverride?: string): Promise<AuthTokenClaims>;
    /**
     * Get the auth token verification key.
     *
     * Note that the verification key is pulled from app settings for the first time only and then
     * cached. On subsequent calls the cached verification key is returned.
     *
     * @returns String holding the verification key.
     */
    getVerificationKey(): Promise<string>;
    /**
     * Verifies a webhook request by checking the signature and asserting the timestamp is
     * within 5 minutes of the current time to prevent replay attacks.
     *
     * @param payload The raw JSON payload/body of the webhook request. This must be unaltered or signature verification will fail.
     * @param headers A JSON object containing the webhook's ID, timestamp, and signature sent in the headers of the webhook request. This input object must contain `id`, `timestamp`, and `signature` keys.
     * @param secret The webhook secret to use for verifying the webhook request.
     * @returns verified payload if the webhook signature is valid otherwise throws.
     */
    verifyWebhook(payload: Object, headers: WebhooksVerificationHeaderInput, secret: string): Promise<unknown>;
    /**
     * Get an access token for the test account for your app. Will throw an error if you have not enabled test credentials in the dashboard.
     * Will throw an error if allowed origins or base domain are enabled for the app.
     *
     * @param {Object} params - An optional object containing email or phoneNumber for the test account.
     * @param {string} params.email - The email of the test account.
     * @param {string} params.phoneNumber - The phone number of the test account.
     * @returns {
     *  token: string
     * }
     */
    getTestAccessToken(params?: {
        email?: string;
        phoneNumber?: string;
    }): Promise<{
        accessToken: string;
    }>;
    /**
     * Add customMetadata field to the user object.
     *
     * @param userId DID of the user to set custom metadata for
     * @param customMetadata the custom metadata to set for the user
     * @returns user object updated with custom metadata
     */
    setCustomMetadata<CustomMetadataInput extends Record<string, string | number | boolean>>(userId: string, customMetadata: CustomMetadataInput): Promise<User>;
    /**
     * Gets a user from the identity token. First, this verifies the token is valid and then parses
     * the payload into a `User` object. Note the user object may be incomplete due to identity token
     * size constraints
     *
     * ```typescript
     * const user = await client.getUser({idToken: cookieIdToken});
     * ```
     *
     * @param idToken the identity token set as a cookie on the users browser
     * @returns the user object with parsed from the ID token
     */
    getUserFromIdToken(idToken: string): Promise<User>;
}

export { AllowlistEntry, AppSettings, Apple, AppleOAuthWithMetadata, AuthTokenClaims, CustomJwt, CustomJwtWithMetadata, Discord, DiscordOAuthWithMetadata, Email, EmailWithMetadata, EthereumPersonalSignRpcInputType, EthereumRpcInputTypes, EthereumSendTransactionInputType, EthereumSendTransactionResponseType, EthereumSendTransactionRpcInputType, EthereumSignMessageInputType, EthereumSignMessageResponseType, EthereumSignTransactionInputType, EthereumSignTransactionResponseType, EthereumSignTransactionRpcInputType, EthereumSignTypedDataInputType, EthereumSignTypedDataResponseType, EthereumSignTypedDataRpcInputType, EvmCaip2ChainId, Farcaster, FarcasterWithMetadata, Github, GithubOAuthWithMetadata, Google, GoogleOAuthWithMetadata, Hex, ImportUserInput, Instagram, InstagramOAuthWithMetadata, LinkedAccountWithMetadata, LinkedIn, LinkedInOAuthWithMetadata, Phone, PhoneWithMetadata, PrivyClient, Quantity, SolanaCaip2ChainId, SolanaRpcInputTypes, SolanaSignAndSendTransactionInputType, SolanaSignAndSendTransactionResponseType, SolanaSignAndSendTransactionRpcInputType, SolanaSignMessageInputType, SolanaSignMessageResponseType, SolanaSignMessageRpcInputType, SolanaSignTransactionInputType, SolanaSignTransactionResponseType, SolanaSignTransactionRpcInputType, Spotify, SpotifyOAuthWithMetadata, Telegram, TelegramWithMetadata, Tiktok, TiktokOAuthWithMetadata, Twitter, TwitterOAuthWithMetadata, User, Wallet, WalletApiCreateRequestType, WalletApiEthereumPersonalSignRpcResponseType, WalletApiEthereumSendTransactionRpcResponseType, WalletApiEthereumSignTransactionRpcResponseType, WalletApiEthereumSignTypedDataRpcResponseType, WalletApiFindWalletsRequestType, WalletApiFindWalletsResponseType, WalletApiRpcInputType, WalletApiRpcInputTypes, WalletApiRpcResponseType, WalletApiSolanaSignAndSendTransactionRpcResponseType, WalletApiSolanaSignMessageRpcResponseType, WalletApiSolanaSignTransactionRpcResponseType, WalletApiWalletResponseType, WalletWithMetadata };
