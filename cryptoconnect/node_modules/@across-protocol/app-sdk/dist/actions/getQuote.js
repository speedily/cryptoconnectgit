import { isHex } from "viem";
import { getMultiCallHandlerAddress, buildMulticallHandlerMessage, } from "../utils/index.js";
import { getSuggestedFees } from "./getSuggestedFees.js";
/**
 * Get a quote for a given set of parameters.
 * @param params - See {@link GetQuoteParams}.
 * @returns See {@link Quote}.
 * @public
 */
export async function getQuote(params) {
    const { route, recipient: _recipient, inputAmount, crossChainMessage, logger, apiUrl, } = params;
    let message = "0x";
    let recipient = _recipient;
    if (isHex(crossChainMessage)) {
        message = crossChainMessage;
    }
    if (crossChainMessage && typeof crossChainMessage === "object") {
        if (crossChainMessage.actions.length === 0) {
            throw new Error("No 'crossChainMessage.actions' provided");
        }
        logger?.debug("Building cross chain message for actions:", crossChainMessage.actions);
        message = buildMulticallHandlerMessage({
            actions: crossChainMessage.actions,
            fallbackRecipient: crossChainMessage.fallbackRecipient,
        });
        logger?.debug("Original message:", message);
        recipient = getMultiCallHandlerAddress(route.destinationChainId);
        logger?.debug(`Recipient ${recipient}`);
    }
    const { outputAmount, ...fees } = await getSuggestedFees({
        ...route,
        amount: inputAmount,
        recipient,
        message,
        logger,
        apiUrl,
        allowUnmatchedDecimals: true,
    });
    logger?.debug("fees", fees);
    // If a given cross-chain message is dependent on the outputAmount, update it
    if (crossChainMessage && typeof crossChainMessage === "object") {
        for (const action of crossChainMessage.actions) {
            let _callData = action.callData;
            let _value = BigInt(action.value);
            if (action?.update) {
                const maybePromise = action.update(outputAmount);
                if (maybePromise instanceof Promise) {
                    const updated = await maybePromise;
                    if (updated?.callData) {
                        _callData = updated.callData;
                    }
                    if (updated?.value) {
                        _value = updated?.value;
                    }
                }
                else {
                    if (maybePromise?.callData) {
                        _callData = maybePromise.callData;
                    }
                    if (maybePromise?.value) {
                        _value = maybePromise?.value;
                    }
                }
            }
            action.callData = _callData;
            action.value = _value;
            logger?.debug("Updated calldata:", action.callData);
            logger?.debug("Updated value:", action.value);
        }
        message = buildMulticallHandlerMessage({
            actions: crossChainMessage.actions,
            fallbackRecipient: crossChainMessage.fallbackRecipient,
        });
        logger?.debug(`Updated message with output amount ${outputAmount}`, message);
    }
    const { 
    // partial deposit args
    timestamp, exclusiveRelayer, exclusivityDeadline, spokePoolAddress, destinationSpokePoolAddress, 
    // limits
    isAmountTooLow, limits, 
    // fees
    lpFee, relayerGasFee, relayerCapitalFee, totalRelayFee, 
    // misc
    estimatedFillTimeSec, fillDeadline, } = fees;
    return {
        deposit: {
            inputAmount: BigInt(inputAmount),
            outputAmount,
            recipient: recipient,
            message,
            quoteTimestamp: Number(timestamp),
            exclusiveRelayer: exclusiveRelayer,
            exclusivityDeadline,
            spokePoolAddress: spokePoolAddress,
            destinationSpokePoolAddress: destinationSpokePoolAddress,
            fillDeadline,
            ...route,
        },
        limits,
        fees: {
            lpFee,
            relayerGasFee,
            relayerCapitalFee,
            totalRelayFee,
        },
        isAmountTooLow,
        estimatedFillTimeSec,
    };
}
//# sourceMappingURL=getQuote.js.map