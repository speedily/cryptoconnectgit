import { HttpError, AcrossApiError, AcrossApiSimulationError, IndexerError, } from "../errors/index.js";
/**
 * Builds a URL search string from an object of query parameters.
 *
 * @param params - An object where keys are query parameter names and values are either a string or an array of strings representing the parameter values.
 *
 * @returns queryString - A properly formatted query string for use in URLs, (without the leading '?').
 */
export function buildSearchParams(params) {
    const searchParams = new URLSearchParams();
    for (const key in params) {
        const value = params[key];
        if (!isDefined(value)) {
            continue;
        }
        if (Array.isArray(value)) {
            value.forEach((val) => searchParams.append(key, String(val)));
        }
        else {
            searchParams.append(key, String(value));
        }
    }
    return searchParams.toString();
}
export function isOk(res) {
    // accept cached responses
    if ((res.status >= 200 && res.status < 300) || res.status === 304) {
        return true;
    }
    return false;
}
export function isDefined(value) {
    return value !== undefined && value !== null ? true : false;
}
function makeFetcher(name, apiErrorHandler) {
    return async (apiUrl, params, logger) => {
        const searchParams = buildSearchParams(params);
        const url = `${apiUrl}?${searchParams}`;
        logger?.debug(`Fetching ${name}...`, url);
        const res = await fetch(url);
        // Try to parse the response as JSON. If it fails, parse it as text.
        let data;
        try {
            data = (await res.json());
        }
        catch (e) {
            data = (await res.text());
        }
        // If the response is OK, return the data
        if (isOk(res)) {
            logger?.debug("OK response", data);
            return data;
        }
        logger?.debug("Error response", {
            status: res.status,
        });
        if (apiErrorHandler) {
            apiErrorHandler(res, data, url);
        }
        throw new HttpError({
            status: res.status,
            message: typeof data === "string" ? data : JSON.stringify(data),
            url,
        });
    };
}
export const fetchAcrossApi = makeFetcher("Across API", (res, data, url) => {
    // Check for Across API errors
    if (typeof data === "object" &&
        data !== null &&
        "type" in data &&
        data.type === "AcrossApiError") {
        const acrossApiError = data;
        if (acrossApiError.code === "SIMULATION_ERROR") {
            throw new AcrossApiSimulationError({
                message: acrossApiError.message,
                url,
                transaction: acrossApiError.transaction,
            });
        }
        throw new AcrossApiError({
            status: res.status,
            message: acrossApiError.message,
            url,
            code: acrossApiError.code,
        });
    }
});
export const fetchIndexerApi = makeFetcher("Indexer API", (res, data, url) => {
    if (typeof data === "object" && data !== null && "error" in data) {
        throw new IndexerError(url, data?.message, data?.error);
    }
});
//# sourceMappingURL=fetch.js.map