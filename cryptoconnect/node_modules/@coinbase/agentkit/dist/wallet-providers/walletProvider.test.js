"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const walletProvider_1 = require("./walletProvider");
const analytics_1 = require("../analytics");
// Mock fetch globally to prevent any actual network requests
global.fetch = jest.fn(() => Promise.resolve({
    ok: true,
    json: () => Promise.resolve({}),
}));
jest.mock("../analytics", () => ({
    sendAnalyticsEvent: jest.fn().mockImplementation(() => Promise.resolve()),
}));
const MOCK_ADDRESS = "0x742d35Cc6634C0532925a3b844Bc454e4438f44e";
const MOCK_NETWORK_ID = "mainnet";
const MOCK_CHAIN_ID = "1";
const MOCK_PROTOCOL_FAMILY = "evm";
const MOCK_WALLET_NAME = "test_wallet_provider";
const MOCK_NETWORK = {
    protocolFamily: MOCK_PROTOCOL_FAMILY,
    networkId: MOCK_NETWORK_ID,
    chainId: MOCK_CHAIN_ID,
};
describe("WalletProvider", () => {
    /**
     *
     */
    class MockWalletProvider extends walletProvider_1.WalletProvider {
        /**
         * Returns the wallet address.
         *
         * @returns The wallet address as a string.
         */
        getAddress() {
            return MOCK_ADDRESS;
        }
        /**
         * Returns the network information.
         *
         * @returns The network details.
         */
        getNetwork() {
            return MOCK_NETWORK;
        }
        /**
         * Returns the wallet provider name.
         *
         * @returns The wallet provider name as a string.
         */
        getName() {
            return MOCK_WALLET_NAME;
        }
        /**
         * Returns the wallet balance.
         *
         * @returns A promise resolving to the wallet balance as a bigint.
         */
        getBalance() {
            return Promise.resolve(BigInt(1000000000000000000));
        }
        /**
         * Transfers native tokens.
         *
         * @param _to - The recipient address.
         * @param _value - The amount to transfer.
         * @returns A promise resolving to the transaction hash as a string.
         */
        nativeTransfer(_to, _value) {
            return Promise.resolve("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef");
        }
        /**
         * Converts the wallet provider to a signer.
         *
         * @returns The signer object.
         */
        toSigner() {
            return {
                address: this.getAddress(),
                signMessage: async (_message) => "0xsigned",
                signTransaction: async (_transaction) => "0xsigned",
                signTypedData: async (_typedData) => "0xsigned",
            };
        }
    }
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it("should define abstract methods (TypeScript only - not a runtime check)", () => { });
    it("should track initialization via analytics", () => {
        new MockWalletProvider();
        return new Promise(resolve => setTimeout(() => {
            expect(analytics_1.sendAnalyticsEvent).toHaveBeenCalledWith({
                name: "agent_initialization",
                action: "initialize_wallet_provider",
                component: "wallet_provider",
                wallet_provider: MOCK_WALLET_NAME,
                wallet_address: MOCK_ADDRESS,
                network_id: MOCK_NETWORK_ID,
                chain_id: MOCK_CHAIN_ID,
                protocol_family: MOCK_PROTOCOL_FAMILY,
            });
            resolve(null);
        }, 0));
    });
    it("should handle tracking failures gracefully", () => {
        analytics_1.sendAnalyticsEvent.mockImplementationOnce(() => {
            throw new Error("Test error");
        });
        const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation(() => { });
        new MockWalletProvider();
        return new Promise(resolve => setTimeout(() => {
            expect(consoleWarnSpy).toHaveBeenCalledWith("Failed to track wallet provider initialization:", expect.any(Error));
            consoleWarnSpy.mockRestore();
            resolve(null);
        }, 0));
    });
    it("should convert wallet provider to signer", () => {
        const provider = new MockWalletProvider();
        const signer = provider.toSigner();
        expect(signer).toBeDefined();
        expect(signer.address).toBe(MOCK_ADDRESS);
        expect(signer.signMessage).toBeDefined();
        expect(signer.signTransaction).toBeDefined();
        expect(signer.signTypedData).toBeDefined();
    });
});
