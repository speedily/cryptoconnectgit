import { z } from "zod";
/**
 * Enum for EthValueOperator values
 */
export declare const EthValueOperatorEnum: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
/**
 * Type representing the operators that can be used for ETH value comparisons.
 * These operators determine how transaction values are compared against thresholds.
 */
export type EthValueOperator = z.infer<typeof EthValueOperatorEnum>;
/**
 * Enum for EvmAddressOperator values
 */
export declare const EvmAddressOperatorEnum: z.ZodEnum<["in", "not in"]>;
/**
 * Type representing the operators that can be used for EVM address comparisons.
 * These operators determine how transaction recipient addresses are evaluated against a list.
 */
export type EvmAddressOperator = z.infer<typeof EvmAddressOperatorEnum>;
/**
 * Enum for EvmNetworkOperator values
 */
export declare const EvmNetworkOperatorEnum: z.ZodEnum<["in", "not in"]>;
/**
 * Type representing the operators that can be used for EVM network comparisons.
 * These operators determine how the transaction's network is evaluated against a list.
 */
export type EvmNetworkOperator = z.infer<typeof EvmNetworkOperatorEnum>;
/**
 * Enum for SolAddressOperator values
 */
export declare const SolAddressOperatorEnum: z.ZodEnum<["in", "not in"]>;
/**
 * Type representing the operators that can be used for Solana address comparisons.
 * These operators determine how transaction addresses are evaluated against a list.
 */
export type SolAddressOperator = z.infer<typeof SolAddressOperatorEnum>;
/**
 * Schema for ETH value criterions
 */
export declare const EthValueCriterionSchema: z.ZodObject<{
    /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
    type: z.ZodLiteral<"ethValue">;
    /**
     * The ETH value amount in wei to compare against, as a string.
     * Must contain only digits.
     */
    ethValue: z.ZodString;
    /** The comparison operator to use for evaluating transaction values against the threshold. */
    operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
}, "strip", z.ZodTypeAny, {
    ethValue: string;
    type: "ethValue";
    operator: ">" | ">=" | "<" | "<=" | "==";
}, {
    ethValue: string;
    type: "ethValue";
    operator: ">" | ">=" | "<" | "<=" | "==";
}>;
export type EthValueCriterion = z.infer<typeof EthValueCriterionSchema>;
/**
 * Schema for EVM address criterions
 */
export declare const EvmAddressCriterionSchema: z.ZodObject<{
    /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
    type: z.ZodLiteral<"evmAddress">;
    /**
     * Array of EVM addresses to compare against.
     * Each address must be a 0x-prefixed 40-character hexadecimal string.
     * Limited to a maximum of 100 addresses per criterion.
     */
    addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: z.ZodEnum<["in", "not in"]>;
}, "strip", z.ZodTypeAny, {
    type: "evmAddress";
    operator: "in" | "not in";
    addresses: `0x${string}`[];
}, {
    type: "evmAddress";
    operator: "in" | "not in";
    addresses: string[];
}>;
export type EvmAddressCriterion = z.infer<typeof EvmAddressCriterionSchema>;
/**
 * Enum for EVM Network values
 */
export declare const EvmNetworkEnum: z.ZodEnum<["base", "base-sepolia"]>;
/**
 * Type representing the valid networks used with CDP transaction API's.
 */
export type EvmNetwork = z.infer<typeof EvmNetworkEnum>;
/**
 * Schema for EVM network criterions
 */
export declare const EvmNetworkCriterionSchema: z.ZodObject<{
    /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
    type: z.ZodLiteral<"evmNetwork">;
    /**
     * Array of EVM network identifiers to compare against.
     * Either "base" or "base-sepolia"
     */
    networks: z.ZodArray<z.ZodEnum<["base", "base-sepolia"]>, "many">;
    /**
     * The operator to use for evaluating transaction network.
     * "in" checks if a network is in the provided list.
     * "not in" checks if a network is not in the provided list.
     */
    operator: z.ZodEnum<["in", "not in"]>;
}, "strip", z.ZodTypeAny, {
    type: "evmNetwork";
    operator: "in" | "not in";
    networks: ("base-sepolia" | "base")[];
}, {
    type: "evmNetwork";
    operator: "in" | "not in";
    networks: ("base-sepolia" | "base")[];
}>;
export type EvmNetworkCriterion = z.infer<typeof EvmNetworkCriterionSchema>;
/**
 * Schema for EVM message criterions
 */
export declare const EvmMessageCriterionSchema: z.ZodObject<{
    /** The type of criterion, must be "evmMessage" for EVM message-based rules. */
    type: z.ZodLiteral<"evmMessage">;
    /**
     * A regular expression the message is matched against.
     * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
     */
    match: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "evmMessage";
    match: string;
}, {
    type: "evmMessage";
    match: string;
}>;
export type EvmMessageCriterion = z.infer<typeof EvmMessageCriterionSchema>;
/**
 * Schema for Solana address criterions
 */
export declare const SolAddressCriterionSchema: z.ZodObject<{
    /** The type of criterion, must be "solAddress" for Solana address-based rules. */
    type: z.ZodLiteral<"solAddress">;
    /**
     * Array of Solana addresses to compare against.
     * Each address must be a valid Base58-encoded Solana address (32-44 characters).
     */
    addresses: z.ZodArray<z.ZodString, "many">;
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: z.ZodEnum<["in", "not in"]>;
}, "strip", z.ZodTypeAny, {
    type: "solAddress";
    operator: "in" | "not in";
    addresses: string[];
}, {
    type: "solAddress";
    operator: "in" | "not in";
    addresses: string[];
}>;
export type SolAddressCriterion = z.infer<typeof SolAddressCriterionSchema>;
/**
 * Schema for criteria used in SignEvmTransaction operations
 */
export declare const SignEvmTransactionCriteriaSchema: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
    type: z.ZodLiteral<"ethValue">;
    /**
     * The ETH value amount in wei to compare against, as a string.
     * Must contain only digits.
     */
    ethValue: z.ZodString;
    /** The comparison operator to use for evaluating transaction values against the threshold. */
    operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
}, "strip", z.ZodTypeAny, {
    ethValue: string;
    type: "ethValue";
    operator: ">" | ">=" | "<" | "<=" | "==";
}, {
    ethValue: string;
    type: "ethValue";
    operator: ">" | ">=" | "<" | "<=" | "==";
}>, z.ZodObject<{
    /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
    type: z.ZodLiteral<"evmAddress">;
    /**
     * Array of EVM addresses to compare against.
     * Each address must be a 0x-prefixed 40-character hexadecimal string.
     * Limited to a maximum of 100 addresses per criterion.
     */
    addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: z.ZodEnum<["in", "not in"]>;
}, "strip", z.ZodTypeAny, {
    type: "evmAddress";
    operator: "in" | "not in";
    addresses: `0x${string}`[];
}, {
    type: "evmAddress";
    operator: "in" | "not in";
    addresses: string[];
}>]>, "many">;
/**
 * Type representing a set of criteria for the signEvmTransaction operation.
 * Can contain up to 10 individual criterion objects of ETH value or EVM address types.
 */
export type SignEvmTransactionCriteria = z.infer<typeof SignEvmTransactionCriteriaSchema>;
/**
 * Schema for criteria used in SignEvmMessage operations
 */
export declare const SignEvmMessageCriteriaSchema: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    /** The type of criterion, must be "evmMessage" for EVM message-based rules. */
    type: z.ZodLiteral<"evmMessage">;
    /**
     * A regular expression the message is matched against.
     * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
     */
    match: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "evmMessage";
    match: string;
}, {
    type: "evmMessage";
    match: string;
}>]>, "many">;
/**
 * Type representing a set of criteria for the signEvmMessage operation.
 * Can contain up to 10 individual EVM message criterion objects.
 */
export type SignEvmMessageCriteria = z.infer<typeof SignEvmMessageCriteriaSchema>;
/**
 * Schema for criteria used in SendEvmTransaction operations
 */
export declare const SendEvmTransactionCriteriaSchema: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
    type: z.ZodLiteral<"ethValue">;
    /**
     * The ETH value amount in wei to compare against, as a string.
     * Must contain only digits.
     */
    ethValue: z.ZodString;
    /** The comparison operator to use for evaluating transaction values against the threshold. */
    operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
}, "strip", z.ZodTypeAny, {
    ethValue: string;
    type: "ethValue";
    operator: ">" | ">=" | "<" | "<=" | "==";
}, {
    ethValue: string;
    type: "ethValue";
    operator: ">" | ">=" | "<" | "<=" | "==";
}>, z.ZodObject<{
    /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
    type: z.ZodLiteral<"evmAddress">;
    /**
     * Array of EVM addresses to compare against.
     * Each address must be a 0x-prefixed 40-character hexadecimal string.
     * Limited to a maximum of 100 addresses per criterion.
     */
    addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: z.ZodEnum<["in", "not in"]>;
}, "strip", z.ZodTypeAny, {
    type: "evmAddress";
    operator: "in" | "not in";
    addresses: `0x${string}`[];
}, {
    type: "evmAddress";
    operator: "in" | "not in";
    addresses: string[];
}>, z.ZodObject<{
    /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
    type: z.ZodLiteral<"evmNetwork">;
    /**
     * Array of EVM network identifiers to compare against.
     * Either "base" or "base-sepolia"
     */
    networks: z.ZodArray<z.ZodEnum<["base", "base-sepolia"]>, "many">;
    /**
     * The operator to use for evaluating transaction network.
     * "in" checks if a network is in the provided list.
     * "not in" checks if a network is not in the provided list.
     */
    operator: z.ZodEnum<["in", "not in"]>;
}, "strip", z.ZodTypeAny, {
    type: "evmNetwork";
    operator: "in" | "not in";
    networks: ("base-sepolia" | "base")[];
}, {
    type: "evmNetwork";
    operator: "in" | "not in";
    networks: ("base-sepolia" | "base")[];
}>]>, "many">;
/**
 * Type representing a set of criteria for the sendEvmTransaction operation.
 * Can contain up to 10 individual criterion objects of ETH value or EVM address types.
 */
export type SendEvmTransactionCriteria = z.infer<typeof SendEvmTransactionCriteriaSchema>;
/**
 * Schema for criteria used in SignSolTransaction operations
 */
export declare const SignSolTransactionCriteriaSchema: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    /** The type of criterion, must be "solAddress" for Solana address-based rules. */
    type: z.ZodLiteral<"solAddress">;
    /**
     * Array of Solana addresses to compare against.
     * Each address must be a valid Base58-encoded Solana address (32-44 characters).
     */
    addresses: z.ZodArray<z.ZodString, "many">;
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: z.ZodEnum<["in", "not in"]>;
}, "strip", z.ZodTypeAny, {
    type: "solAddress";
    operator: "in" | "not in";
    addresses: string[];
}, {
    type: "solAddress";
    operator: "in" | "not in";
    addresses: string[];
}>]>, "many">;
/**
 * Type representing a set of criteria for the signSolTransaction operation.
 * Can contain up to 10 individual Solana address criterion objects.
 */
export type SignSolTransactionCriteria = z.infer<typeof SignSolTransactionCriteriaSchema>;
/**
 * Enum for Solana Operation types
 */
export declare const SolOperationEnum: z.ZodEnum<["signSolTransaction"]>;
/**
 * Type representing the operations that can be governed by a policy.
 * Defines what Solana operations the policy applies to.
 */
export type SolOperation = z.infer<typeof SolOperationEnum>;
/**
 * Enum for Evm Operation types
 */
export declare const EvmOperationEnum: z.ZodEnum<["signEvmTransaction"]>;
/**
 * Type representing the operations that can be governed by a policy.
 * Defines what EVM operations the policy applies to.
 */
export type EvmOperation = z.infer<typeof EvmOperationEnum>;
/**
 * Enum for Action types
 */
export declare const ActionEnum: z.ZodEnum<["reject", "accept"]>;
/**
 * Type representing the possible policy actions.
 * Determines whether matching the rule will cause a request to be accepted or rejected.
 */
export type Action = z.infer<typeof ActionEnum>;
/**
 * Type representing a 'signEvmTransaction' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export declare const SignEvmTransactionRuleSchema: z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signEvmTransaction".
     */
    operation: z.ZodLiteral<"signEvmTransaction">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
        type: z.ZodLiteral<"ethValue">;
        /**
         * The ETH value amount in wei to compare against, as a string.
         * Must contain only digits.
         */
        ethValue: z.ZodString;
        /** The comparison operator to use for evaluating transaction values against the threshold. */
        operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
    }, "strip", z.ZodTypeAny, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }>, z.ZodObject<{
        /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
        type: z.ZodLiteral<"evmAddress">;
        /**
         * Array of EVM addresses to compare against.
         * Each address must be a 0x-prefixed 40-character hexadecimal string.
         * Limited to a maximum of 100 addresses per criterion.
         */
        addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
        /**
         * The operator to use for evaluating transaction addresses.
         * "in" checks if an address is in the provided list.
         * "not in" checks if an address is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    }, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    })[];
}, {
    action: "reject" | "accept";
    operation: "signEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    })[];
}>;
export type SignEvmTransactionRule = z.infer<typeof SignEvmTransactionRuleSchema>;
/**
 * Type representing a 'signEvmHash' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export declare const SignEvmHashRuleSchema: z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the signing, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signEvmHash".
     */
    operation: z.ZodLiteral<"signEvmHash">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signEvmHash";
}, {
    action: "reject" | "accept";
    operation: "signEvmHash";
}>;
export type SignEvmHashRule = z.infer<typeof SignEvmHashRuleSchema>;
/**
 * Type representing a 'signEvmMessage' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export declare const SignEvmMessageRuleSchema: z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the signing, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signEvmMessage".
     */
    operation: z.ZodLiteral<"signEvmMessage">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "evmMessage" for EVM message-based rules. */
        type: z.ZodLiteral<"evmMessage">;
        /**
         * A regular expression the message is matched against.
         * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
         */
        match: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "evmMessage";
        match: string;
    }, {
        type: "evmMessage";
        match: string;
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signEvmMessage";
    criteria: {
        type: "evmMessage";
        match: string;
    }[];
}, {
    action: "reject" | "accept";
    operation: "signEvmMessage";
    criteria: {
        type: "evmMessage";
        match: string;
    }[];
}>;
export type SignEvmMessageRule = z.infer<typeof SignEvmMessageRuleSchema>;
/**
 * Type representing a 'sendEvmTransaction' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export declare const SendEvmTransactionRuleSchema: z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "sendEvmTransaction".
     */
    operation: z.ZodLiteral<"sendEvmTransaction">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
        type: z.ZodLiteral<"ethValue">;
        /**
         * The ETH value amount in wei to compare against, as a string.
         * Must contain only digits.
         */
        ethValue: z.ZodString;
        /** The comparison operator to use for evaluating transaction values against the threshold. */
        operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
    }, "strip", z.ZodTypeAny, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }>, z.ZodObject<{
        /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
        type: z.ZodLiteral<"evmAddress">;
        /**
         * Array of EVM addresses to compare against.
         * Each address must be a 0x-prefixed 40-character hexadecimal string.
         * Limited to a maximum of 100 addresses per criterion.
         */
        addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
        /**
         * The operator to use for evaluating transaction addresses.
         * "in" checks if an address is in the provided list.
         * "not in" checks if an address is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    }, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    }>, z.ZodObject<{
        /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
        type: z.ZodLiteral<"evmNetwork">;
        /**
         * Array of EVM network identifiers to compare against.
         * Either "base" or "base-sepolia"
         */
        networks: z.ZodArray<z.ZodEnum<["base", "base-sepolia"]>, "many">;
        /**
         * The operator to use for evaluating transaction network.
         * "in" checks if a network is in the provided list.
         * "not in" checks if a network is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    }, {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "sendEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    } | {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    })[];
}, {
    action: "reject" | "accept";
    operation: "sendEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    } | {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    })[];
}>;
export type SendEvmTransactionRule = z.infer<typeof SendEvmTransactionRuleSchema>;
/**
 * Type representing a 'signSolTransaction' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export declare const SignSolTransactionRuleSchema: z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signSolTransaction".
     */
    operation: z.ZodLiteral<"signSolTransaction">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "solAddress" for Solana address-based rules. */
        type: z.ZodLiteral<"solAddress">;
        /**
         * Array of Solana addresses to compare against.
         * Each address must be a valid Base58-encoded Solana address (32-44 characters).
         */
        addresses: z.ZodArray<z.ZodString, "many">;
        /**
         * The operator to use for evaluating transaction addresses.
         * "in" checks if an address is in the provided list.
         * "not in" checks if an address is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }, {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signSolTransaction";
    criteria: {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }[];
}, {
    action: "reject" | "accept";
    operation: "signSolTransaction";
    criteria: {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }[];
}>;
export type SignSolTransactionRule = z.infer<typeof SignSolTransactionRuleSchema>;
/**
 * Schema for policy rules
 */
export declare const RuleSchema: z.ZodDiscriminatedUnion<"operation", [z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signEvmTransaction".
     */
    operation: z.ZodLiteral<"signEvmTransaction">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
        type: z.ZodLiteral<"ethValue">;
        /**
         * The ETH value amount in wei to compare against, as a string.
         * Must contain only digits.
         */
        ethValue: z.ZodString;
        /** The comparison operator to use for evaluating transaction values against the threshold. */
        operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
    }, "strip", z.ZodTypeAny, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }>, z.ZodObject<{
        /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
        type: z.ZodLiteral<"evmAddress">;
        /**
         * Array of EVM addresses to compare against.
         * Each address must be a 0x-prefixed 40-character hexadecimal string.
         * Limited to a maximum of 100 addresses per criterion.
         */
        addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
        /**
         * The operator to use for evaluating transaction addresses.
         * "in" checks if an address is in the provided list.
         * "not in" checks if an address is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    }, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    })[];
}, {
    action: "reject" | "accept";
    operation: "signEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    })[];
}>, z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the signing, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signEvmHash".
     */
    operation: z.ZodLiteral<"signEvmHash">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signEvmHash";
}, {
    action: "reject" | "accept";
    operation: "signEvmHash";
}>, z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the signing, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signEvmMessage".
     */
    operation: z.ZodLiteral<"signEvmMessage">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "evmMessage" for EVM message-based rules. */
        type: z.ZodLiteral<"evmMessage">;
        /**
         * A regular expression the message is matched against.
         * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
         */
        match: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "evmMessage";
        match: string;
    }, {
        type: "evmMessage";
        match: string;
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signEvmMessage";
    criteria: {
        type: "evmMessage";
        match: string;
    }[];
}, {
    action: "reject" | "accept";
    operation: "signEvmMessage";
    criteria: {
        type: "evmMessage";
        match: string;
    }[];
}>, z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "sendEvmTransaction".
     */
    operation: z.ZodLiteral<"sendEvmTransaction">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
        type: z.ZodLiteral<"ethValue">;
        /**
         * The ETH value amount in wei to compare against, as a string.
         * Must contain only digits.
         */
        ethValue: z.ZodString;
        /** The comparison operator to use for evaluating transaction values against the threshold. */
        operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
    }, "strip", z.ZodTypeAny, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }, {
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    }>, z.ZodObject<{
        /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
        type: z.ZodLiteral<"evmAddress">;
        /**
         * Array of EVM addresses to compare against.
         * Each address must be a 0x-prefixed 40-character hexadecimal string.
         * Limited to a maximum of 100 addresses per criterion.
         */
        addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
        /**
         * The operator to use for evaluating transaction addresses.
         * "in" checks if an address is in the provided list.
         * "not in" checks if an address is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    }, {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    }>, z.ZodObject<{
        /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
        type: z.ZodLiteral<"evmNetwork">;
        /**
         * Array of EVM network identifiers to compare against.
         * Either "base" or "base-sepolia"
         */
        networks: z.ZodArray<z.ZodEnum<["base", "base-sepolia"]>, "many">;
        /**
         * The operator to use for evaluating transaction network.
         * "in" checks if a network is in the provided list.
         * "not in" checks if a network is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    }, {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "sendEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: `0x${string}`[];
    } | {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    })[];
}, {
    action: "reject" | "accept";
    operation: "sendEvmTransaction";
    criteria: ({
        ethValue: string;
        type: "ethValue";
        operator: ">" | ">=" | "<" | "<=" | "==";
    } | {
        type: "evmAddress";
        operator: "in" | "not in";
        addresses: string[];
    } | {
        type: "evmNetwork";
        operator: "in" | "not in";
        networks: ("base-sepolia" | "base")[];
    })[];
}>, z.ZodObject<{
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: z.ZodEnum<["reject", "accept"]>;
    /**
     * The operation to which this rule applies.
     * Must be "signSolTransaction".
     */
    operation: z.ZodLiteral<"signSolTransaction">;
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        /** The type of criterion, must be "solAddress" for Solana address-based rules. */
        type: z.ZodLiteral<"solAddress">;
        /**
         * Array of Solana addresses to compare against.
         * Each address must be a valid Base58-encoded Solana address (32-44 characters).
         */
        addresses: z.ZodArray<z.ZodString, "many">;
        /**
         * The operator to use for evaluating transaction addresses.
         * "in" checks if an address is in the provided list.
         * "not in" checks if an address is not in the provided list.
         */
        operator: z.ZodEnum<["in", "not in"]>;
    }, "strip", z.ZodTypeAny, {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }, {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    action: "reject" | "accept";
    operation: "signSolTransaction";
    criteria: {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }[];
}, {
    action: "reject" | "accept";
    operation: "signSolTransaction";
    criteria: {
        type: "solAddress";
        operator: "in" | "not in";
        addresses: string[];
    }[];
}>]>;
/**
 * Type representing a policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export type Rule = z.infer<typeof RuleSchema>;
/**
 * Enum for policy scopes
 */
export declare const PolicyScopeEnum: z.ZodEnum<["project", "account"]>;
/**
 * Type representing the scope of a policy.
 * Determines whether the policy applies at the project level or account level.
 */
export type PolicyScope = z.infer<typeof PolicyScopeEnum>;
/**
 * Schema for creating or updating a Policy.
 */
export declare const CreatePolicyBodySchema: z.ZodObject<{
    /**
     * The scope of the policy.
     * "project" applies to the entire project, "account" applies to specific accounts.
     */
    scope: z.ZodEnum<["project", "account"]>;
    /**
     * An optional human-readable description for the policy.
     * Limited to 50 characters of alphanumeric characters, spaces, commas, and periods.
     */
    description: z.ZodOptional<z.ZodString>;
    /**
     * Array of rules that comprise the policy.
     * Limited to a maximum of 10 rules per policy.
     */
    rules: z.ZodArray<z.ZodDiscriminatedUnion<"operation", [z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the transaction, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signEvmTransaction".
         */
        operation: z.ZodLiteral<"signEvmTransaction">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
            type: z.ZodLiteral<"ethValue">;
            /**
             * The ETH value amount in wei to compare against, as a string.
             * Must contain only digits.
             */
            ethValue: z.ZodString;
            /** The comparison operator to use for evaluating transaction values against the threshold. */
            operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
        }, "strip", z.ZodTypeAny, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }>, z.ZodObject<{
            /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
            type: z.ZodLiteral<"evmAddress">;
            /**
             * Array of EVM addresses to compare against.
             * Each address must be a 0x-prefixed 40-character hexadecimal string.
             * Limited to a maximum of 100 addresses per criterion.
             */
            addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
            /**
             * The operator to use for evaluating transaction addresses.
             * "in" checks if an address is in the provided list.
             * "not in" checks if an address is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        }, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        })[];
    }, {
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        })[];
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the signing, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signEvmHash".
         */
        operation: z.ZodLiteral<"signEvmHash">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signEvmHash";
    }, {
        action: "reject" | "accept";
        operation: "signEvmHash";
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the signing, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signEvmMessage".
         */
        operation: z.ZodLiteral<"signEvmMessage">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "evmMessage" for EVM message-based rules. */
            type: z.ZodLiteral<"evmMessage">;
            /**
             * A regular expression the message is matched against.
             * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
             */
            match: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "evmMessage";
            match: string;
        }, {
            type: "evmMessage";
            match: string;
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    }, {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the transaction, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "sendEvmTransaction".
         */
        operation: z.ZodLiteral<"sendEvmTransaction">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
            type: z.ZodLiteral<"ethValue">;
            /**
             * The ETH value amount in wei to compare against, as a string.
             * Must contain only digits.
             */
            ethValue: z.ZodString;
            /** The comparison operator to use for evaluating transaction values against the threshold. */
            operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
        }, "strip", z.ZodTypeAny, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }>, z.ZodObject<{
            /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
            type: z.ZodLiteral<"evmAddress">;
            /**
             * Array of EVM addresses to compare against.
             * Each address must be a 0x-prefixed 40-character hexadecimal string.
             * Limited to a maximum of 100 addresses per criterion.
             */
            addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
            /**
             * The operator to use for evaluating transaction addresses.
             * "in" checks if an address is in the provided list.
             * "not in" checks if an address is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        }, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        }>, z.ZodObject<{
            /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
            type: z.ZodLiteral<"evmNetwork">;
            /**
             * Array of EVM network identifiers to compare against.
             * Either "base" or "base-sepolia"
             */
            networks: z.ZodArray<z.ZodEnum<["base", "base-sepolia"]>, "many">;
            /**
             * The operator to use for evaluating transaction network.
             * "in" checks if a network is in the provided list.
             * "not in" checks if a network is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        }, {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    }, {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the transaction, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signSolTransaction".
         */
        operation: z.ZodLiteral<"signSolTransaction">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "solAddress" for Solana address-based rules. */
            type: z.ZodLiteral<"solAddress">;
            /**
             * Array of Solana addresses to compare against.
             * Each address must be a valid Base58-encoded Solana address (32-44 characters).
             */
            addresses: z.ZodArray<z.ZodString, "many">;
            /**
             * The operator to use for evaluating transaction addresses.
             * "in" checks if an address is in the provided list.
             * "not in" checks if an address is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }, {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    }, {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    scope: "project" | "account";
    rules: ({
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signEvmHash";
    } | {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    } | {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    })[];
    description?: string | undefined;
}, {
    scope: "project" | "account";
    rules: ({
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signEvmHash";
    } | {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    } | {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    })[];
    description?: string | undefined;
}>;
/**
 * Type representing the request body for creating a new policy.
 * Contains the scope, optional description, and rules for the policy.
 */
export type CreatePolicyBody = z.infer<typeof CreatePolicyBodySchema>;
export declare const UpdatePolicyBodySchema: z.ZodObject<{
    /**
     * An optional human-readable description for the policy.
     * Limited to 50 characters of alphanumeric characters, spaces, commas, and periods.
     */
    description: z.ZodOptional<z.ZodString>;
    /**
     * Array of rules that comprise the policy.
     * Limited to a maximum of 10 rules per policy.
     */
    rules: z.ZodArray<z.ZodDiscriminatedUnion<"operation", [z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the transaction, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signEvmTransaction".
         */
        operation: z.ZodLiteral<"signEvmTransaction">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
            type: z.ZodLiteral<"ethValue">;
            /**
             * The ETH value amount in wei to compare against, as a string.
             * Must contain only digits.
             */
            ethValue: z.ZodString;
            /** The comparison operator to use for evaluating transaction values against the threshold. */
            operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
        }, "strip", z.ZodTypeAny, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }>, z.ZodObject<{
            /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
            type: z.ZodLiteral<"evmAddress">;
            /**
             * Array of EVM addresses to compare against.
             * Each address must be a 0x-prefixed 40-character hexadecimal string.
             * Limited to a maximum of 100 addresses per criterion.
             */
            addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
            /**
             * The operator to use for evaluating transaction addresses.
             * "in" checks if an address is in the provided list.
             * "not in" checks if an address is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        }, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        })[];
    }, {
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        })[];
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the signing, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signEvmHash".
         */
        operation: z.ZodLiteral<"signEvmHash">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signEvmHash";
    }, {
        action: "reject" | "accept";
        operation: "signEvmHash";
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the signing, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signEvmMessage".
         */
        operation: z.ZodLiteral<"signEvmMessage">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "evmMessage" for EVM message-based rules. */
            type: z.ZodLiteral<"evmMessage">;
            /**
             * A regular expression the message is matched against.
             * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
             */
            match: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "evmMessage";
            match: string;
        }, {
            type: "evmMessage";
            match: string;
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    }, {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the transaction, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "sendEvmTransaction".
         */
        operation: z.ZodLiteral<"sendEvmTransaction">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
            type: z.ZodLiteral<"ethValue">;
            /**
             * The ETH value amount in wei to compare against, as a string.
             * Must contain only digits.
             */
            ethValue: z.ZodString;
            /** The comparison operator to use for evaluating transaction values against the threshold. */
            operator: z.ZodEnum<[">", ">=", "<", "<=", "=="]>;
        }, "strip", z.ZodTypeAny, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }, {
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        }>, z.ZodObject<{
            /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
            type: z.ZodLiteral<"evmAddress">;
            /**
             * Array of EVM addresses to compare against.
             * Each address must be a 0x-prefixed 40-character hexadecimal string.
             * Limited to a maximum of 100 addresses per criterion.
             */
            addresses: z.ZodArray<z.ZodEffects<z.ZodString, `0x${string}`, string>, "many">;
            /**
             * The operator to use for evaluating transaction addresses.
             * "in" checks if an address is in the provided list.
             * "not in" checks if an address is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        }, {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        }>, z.ZodObject<{
            /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
            type: z.ZodLiteral<"evmNetwork">;
            /**
             * Array of EVM network identifiers to compare against.
             * Either "base" or "base-sepolia"
             */
            networks: z.ZodArray<z.ZodEnum<["base", "base-sepolia"]>, "many">;
            /**
             * The operator to use for evaluating transaction network.
             * "in" checks if a network is in the provided list.
             * "not in" checks if a network is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        }, {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    }, {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    }>, z.ZodObject<{
        /**
         * Determines whether matching the rule will cause a request to be rejected or accepted.
         * "accept" will allow the transaction, "reject" will block it.
         */
        action: z.ZodEnum<["reject", "accept"]>;
        /**
         * The operation to which this rule applies.
         * Must be "signSolTransaction".
         */
        operation: z.ZodLiteral<"signSolTransaction">;
        /**
         * The set of criteria that must be matched for this rule to apply.
         * Must be compatible with the specified operation type.
         */
        criteria: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            /** The type of criterion, must be "solAddress" for Solana address-based rules. */
            type: z.ZodLiteral<"solAddress">;
            /**
             * Array of Solana addresses to compare against.
             * Each address must be a valid Base58-encoded Solana address (32-44 characters).
             */
            addresses: z.ZodArray<z.ZodString, "many">;
            /**
             * The operator to use for evaluating transaction addresses.
             * "in" checks if an address is in the provided list.
             * "not in" checks if an address is not in the provided list.
             */
            operator: z.ZodEnum<["in", "not in"]>;
        }, "strip", z.ZodTypeAny, {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }, {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }>]>, "many">;
    }, "strip", z.ZodTypeAny, {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    }, {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    }>]>, "many">;
}, "strip", z.ZodTypeAny, {
    rules: ({
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signEvmHash";
    } | {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    } | {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: `0x${string}`[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    })[];
    description?: string | undefined;
}, {
    rules: ({
        action: "reject" | "accept";
        operation: "signEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signEvmHash";
    } | {
        action: "reject" | "accept";
        operation: "signEvmMessage";
        criteria: {
            type: "evmMessage";
            match: string;
        }[];
    } | {
        action: "reject" | "accept";
        operation: "sendEvmTransaction";
        criteria: ({
            ethValue: string;
            type: "ethValue";
            operator: ">" | ">=" | "<" | "<=" | "==";
        } | {
            type: "evmAddress";
            operator: "in" | "not in";
            addresses: string[];
        } | {
            type: "evmNetwork";
            operator: "in" | "not in";
            networks: ("base-sepolia" | "base")[];
        })[];
    } | {
        action: "reject" | "accept";
        operation: "signSolTransaction";
        criteria: {
            type: "solAddress";
            operator: "in" | "not in";
            addresses: string[];
        }[];
    })[];
    description?: string | undefined;
}>;
/**
 * Type representing the request body for updating an existing policy.
 * Contains the optional description and rules for the updated policy.
 * Note that the scope cannot be changed once a policy is created.
 */
export type UpdatePolicyBody = z.infer<typeof UpdatePolicyBodySchema>;
//# sourceMappingURL=schema.d.ts.map